{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f0559284_12f27688",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T12:48:53Z",
      "side": 1,
      "message": "I actually wondering about adding something like this but I did not know how, and you beat me to it!. Thank you. Only one comment, please add some tests.",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e0666dc2_c27f214b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T13:12:08Z",
      "side": 1,
      "message": "I just realized while migrating some existing code to this new interface that the productmanifold now has the problem that it cannot be composed out of instances of Manifold interface anymore, you must have access to the concrete subtype of Manifold at all times. \n\nThis is not a problem when you use ProductManifold immediately, but if you are building a more sophisticated problem solver like say a distributed solver where you maybe passing pointers of type Manifold around, which would have worked before, it won\u0027t work anymore. \n\nBut this should be solvable no? while Manifold itself is not copyable/movable, we could easily construct a thin wrapper that takes a Manifold pointer and owns it and behaves likes a Manifold object, and all this should be doable automatically maybe with a helper function which constructs such an object from pointers somethign like\n\n\nclass ManifoldWrapper : Manifold {\n  // everything gets delegated to manifold_\n  std::unique_ptr\u003cManifold\u003e manifold_;\n}\n\nstd::unique_ptr\u003cManifold\u003e CreateProductManifoldFromPtrs(Manifold* ...) {\n   // wrap each Manifold* into a ManifoldWrapper \n   // Construct a ProductManifold of ManifoldWrappers.\n}\n\nwhat do you think? or perhaps there is a better solution? ",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a928644_d89ef617",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 80,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T12:48:53Z",
      "side": 1,
      "message": "tests for this constructor?",
      "range": {
        "startLine": 80,
        "startChar": 2,
        "endLine": 80,
        "endChar": 17
      },
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a90de5a5_a3f457a3",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 80,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T13:53:22Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a928644_d89ef617",
      "range": {
        "startLine": 80,
        "startChar": 2,
        "endLine": 80,
        "endChar": 17
      },
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b291884_c81fea66",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T13:16:48Z",
      "side": 1,
      "message": "We can reduce constructor overloads to a single one if we do not require at least two manifolds to be specified during `ProductManifold` if any are given. The construction logic can be handled by perfect forwarding using a single constructor.\n\nI believe enforcing the number of constructor parameters is not necessary anymore because this is done by class template parameters already. Also, it would further simplify submanifold handling: a user may choose to place a non-default constructible manifold first, and those with a default constructor after that.\n\nAny objections?",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff497439_88c08544",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T13:21:18Z",
      "side": 1,
      "message": "I think thats fine by me.",
      "parentUuid": "3b291884_c81fea66",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "704cfb47_e5fb3226",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T13:53:22Z",
      "side": 1,
      "message": "Actually, `std::tuple` requires that one passes an argument for each type or none at all. There\u0027s no inbetween which is perfectly fine too.",
      "parentUuid": "ff497439_88c08544",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}