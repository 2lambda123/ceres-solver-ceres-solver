{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f0559284_12f27688",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T12:48:53Z",
      "side": 1,
      "message": "I actually wondering about adding something like this but I did not know how, and you beat me to it!. Thank you. Only one comment, please add some tests.",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e0666dc2_c27f214b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T13:12:08Z",
      "side": 1,
      "message": "I just realized while migrating some existing code to this new interface that the productmanifold now has the problem that it cannot be composed out of instances of Manifold interface anymore, you must have access to the concrete subtype of Manifold at all times. \n\nThis is not a problem when you use ProductManifold immediately, but if you are building a more sophisticated problem solver like say a distributed solver where you maybe passing pointers of type Manifold around, which would have worked before, it won\u0027t work anymore. \n\nBut this should be solvable no? while Manifold itself is not copyable/movable, we could easily construct a thin wrapper that takes a Manifold pointer and owns it and behaves likes a Manifold object, and all this should be doable automatically maybe with a helper function which constructs such an object from pointers somethign like\n\n\nclass ManifoldWrapper : Manifold {\n  // everything gets delegated to manifold_\n  std::unique_ptr\u003cManifold\u003e manifold_;\n}\n\nstd::unique_ptr\u003cManifold\u003e CreateProductManifoldFromPtrs(Manifold* ...) {\n   // wrap each Manifold* into a ManifoldWrapper \n   // Construct a ProductManifold of ManifoldWrappers.\n}\n\nwhat do you think? or perhaps there is a better solution? ",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ac72660_b90f993a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T14:07:56Z",
      "side": 1,
      "message": "I think it would make sense to allow passing directly pointer types:\n```\nProductManifold\u003cManifold1*, Manifold2\u003e\n```\nThen the user could store `Manifold1` in a `std::unique_ptr` somewhere else without `ProductManifold` taking ownership.\n\nIf we provide a thin wrapper, `CreateProductManifoldFromPtrs` is not really needed.",
      "parentUuid": "e0666dc2_c27f214b",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b155860c_e48406ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T14:13:00Z",
      "side": 1,
      "message": "I do not think the user wants to keep the ownership somewhere else. it makes things complicated. I think it is simpler for the wrapper should take ownership.",
      "parentUuid": "3ac72660_b90f993a",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "11208602_ac07c8d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T14:16:26Z",
      "side": 1,
      "message": "I believe I\u0027m missing something. What\u0027s the point of storing a manifold in a `std::unique_ptr` which is immediately moved into `ProductManifold`? Wouldn\u0027t that be same as not using `std::unique_ptr`?",
      "parentUuid": "b155860c_e48406ab",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0e9fa1ae_5ddb3283",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T14:18:49Z",
      "side": 1,
      "message": "The use case is that the user has some manifolds constructed and will at runtime decide to compose them for whatever reason, so they need someone to own the manifolds, it makes sense for the productmanifold to own them (as it did previously) but now since we are storing tuples of manifolds rather then pointers we will need to construct a ManifoldWrapper that holds the pointer and acts as a concrete class which is then owner by a ProductManifold.\n\ndoes that make sense?",
      "parentUuid": "11208602_ac07c8d7",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bc9b6d88_a935ec68",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T14:35:58Z",
      "side": 1,
      "message": "Do you have a specific example?\n\nCurrently, I see two cases:\n1. The user stores the manifold in a `ProductManifold` (already supported)\n2. The user constructs a manifold elsewhere, stores it in a, say, `std::unique_ptr` and passes the reference around to (possibly several) `ProductManifold` instances.\n\nIf ManifoldWrapper store the reference to `Manifold` in a `std::unique_ptr` that would be equivalent to 1. I believe you want to store the instance as a plain pointer in ManifoldWrapper to be able to share it. In this case, we can however allow pointer types to be passed to `ProductManifold` directly. No thin wrapper necessary.\n\nExample:\n```\nstd::unique_ptr\u003cMyHeavyManifold\u003e ptr{...};\n\nProductManifold\u003cMyHeavyManifold*, OtherManifold1\u003e prod1{ptr.get(), ...};\nProductManifold\u003cMyHeavyManifold*, OtherManifold2\u003e prod1{ptr.get(), ...};\n```",
      "parentUuid": "0e9fa1ae_5ddb3283",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "046f8463_7ea875ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T14:45:23Z",
      "side": 1,
      "message": "We could also easily support something like this:\n```\nProductManifold\u003cstd::unique_ptr\u003cManifold\u003e, ...\u003e manifold;\n```\nIs this what you have in mind?",
      "parentUuid": "bc9b6d88_a935ec68",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a928644_d89ef617",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 80,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T12:48:53Z",
      "side": 1,
      "message": "tests for this constructor?",
      "range": {
        "startLine": 80,
        "startChar": 2,
        "endLine": 80,
        "endChar": 17
      },
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a90de5a5_a3f457a3",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 80,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T13:53:22Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a928644_d89ef617",
      "range": {
        "startLine": 80,
        "startChar": 2,
        "endLine": 80,
        "endChar": 17
      },
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b291884_c81fea66",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T13:16:48Z",
      "side": 1,
      "message": "We can reduce constructor overloads to a single one if we do not require at least two manifolds to be specified during `ProductManifold` if any are given. The construction logic can be handled by perfect forwarding using a single constructor.\n\nI believe enforcing the number of constructor parameters is not necessary anymore because this is done by class template parameters already. Also, it would further simplify submanifold handling: a user may choose to place a non-default constructible manifold first, and those with a default constructor after that.\n\nAny objections?",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff497439_88c08544",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-03T13:21:18Z",
      "side": 1,
      "message": "I think thats fine by me.",
      "parentUuid": "3b291884_c81fea66",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "704cfb47_e5fb3226",
        "filename": "include/ceres/product_manifold.h",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-03T13:53:22Z",
      "side": 1,
      "message": "Actually, `std::tuple` requires that one passes an argument for each type or none at all. There\u0027s no inbetween which is perfectly fine too.",
      "parentUuid": "ff497439_88c08544",
      "revId": "51458a7acb0ad6cefd164512185606cc7504d03c",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}