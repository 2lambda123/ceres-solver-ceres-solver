{
  "comments": [
    {
      "key": {
        "uuid": "56219e7f_33eadbc8",
        "filename": "internal/ceres/preprocessor.cc",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 5002
      },
      "writtenOn": "2018-09-12T17:55:34Z",
      "side": 1,
      "message": "nice fix.",
      "revId": "df6e27e13badedabca4ff3ade8fdbd2ab6181666",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90494190_0a7ed636",
        "filename": "internal/ceres/thread_pool.cc",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 5002
      },
      "writtenOn": "2018-09-12T17:55:34Z",
      "side": 1,
      "message": "is this right? where if this is zero we go to max?",
      "range": {
        "startLine": 57,
        "startChar": 13,
        "endLine": 57,
        "endChar": 27
      },
      "revId": "df6e27e13badedabca4ff3ade8fdbd2ab6181666",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37602015_0cce6851",
        "filename": "internal/ceres/thread_pool.cc",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 5155
      },
      "writtenOn": "2018-09-12T18:20:04Z",
      "side": 1,
      "message": "It replicates the behaviour from before, in that we will always take whatever value the user specifies and try to use it (and report it).\n\nI don\u0027t really see what our other options would be here, 11? 42?  All of these are likely arbitrary and would inflame someone with £££ and a lot of cores.  Although in my experience std::thread::hardware_concurrency() has always returned sane values.",
      "parentUuid": "90494190_0a7ed636",
      "range": {
        "startLine": 57,
        "startChar": 13,
        "endLine": 57,
        "endChar": 27
      },
      "revId": "df6e27e13badedabca4ff3ade8fdbd2ab6181666",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "498ddc12_269aed4b",
        "filename": "internal/ceres/thread_pool.cc",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 5435
      },
      "writtenOn": "2018-09-12T18:30:27Z",
      "side": 1,
      "message": "In a previous review, William thought it was best to respect the users thread count request when std::thread::hardware_concurrency() returns 0.  This does that, but it took me a minute to understand return max here doesn\u0027t say to use max threads, but to not restrict the number of threads the user requested.",
      "parentUuid": "37602015_0cce6851",
      "range": {
        "startLine": 57,
        "startChar": 13,
        "endLine": 57,
        "endChar": 27
      },
      "revId": "df6e27e13badedabca4ff3ade8fdbd2ab6181666",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8384c203_0fd53f13",
        "filename": "internal/ceres/thread_pool.cc",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 5002
      },
      "writtenOn": "2018-09-12T18:35:54Z",
      "side": 1,
      "message": "yes I agree this does it but it depends on the GetNumAllowedThreads() call to enforce to min.\n\nI am just trying to reason about the semantics of this function on its own.\nmy suggestion is, if num_hardware_threads \u003d\u003d 0, then this function should also return zero, with the same semantics, that we have no idea really.\n\nand GetNumAllowedThreads  should deal with the zero case specifically. \n\ninstead of doing a maxint here and depending on a min outside.",
      "parentUuid": "498ddc12_269aed4b",
      "range": {
        "startLine": 57,
        "startChar": 13,
        "endLine": 57,
        "endChar": 27
      },
      "revId": "df6e27e13badedabca4ff3ade8fdbd2ab6181666",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3df80f56_186f24e8",
        "filename": "internal/ceres/thread_pool.cc",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 5155
      },
      "writtenOn": "2018-09-13T08:27:55Z",
      "side": 1,
      "message": "I think it\u0027s less intuitive to have this function return a special case that then has to be handed externally.  In terms of the semantics of what will happen if it hardware_concurrency() returns 0, we will blindly try to create as many threads as the user specifies, with no other limits applied (other than the max of ThreadPool::Size()) which is represented by the current behaviour, in that the without any information to the contrary we assume that there is no upper limit.\n\nTBH, I\u0027m wondering about whether we should use hardware_concurrency() at all as a hard maximum.  What if its \u003e 0, but wrong?  For the machines I have to hand (all modern Intel x86) it returns the number of HyperThreaded logical cores (e.g. 8 on a 4-core machine) but I\u0027ve no idea what it does with Zen CPUs or the previous AMD generation CPUs that had faux-HT.\n\nI\u0027m wondering whether we should limit the number of threads at all except in the case of OpenMP when we know there is actually a hard limit we can\u0027t exceed.  In the case of the ThreadPool, we\u0027re imposing an artificial limit based on a function that we know doesn\u0027t always return the right answer, and in one of those failure modes we say the answer is unlimited, why don\u0027t we always do that, as we can after all spawn as many threads as we like, and then have a LOG(WARNING) if it appears to be \u003e hardware_concurrency() but continue with what the user asked for?",
      "parentUuid": "8384c203_0fd53f13",
      "range": {
        "startLine": 57,
        "startChar": 13,
        "endLine": 57,
        "endChar": 27
      },
      "revId": "df6e27e13badedabca4ff3ade8fdbd2ab6181666",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    }
  ]
}