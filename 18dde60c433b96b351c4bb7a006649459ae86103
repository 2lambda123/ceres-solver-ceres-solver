{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c520f33a_282bdfae",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 794,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-07T19:52:56Z",
      "side": 1,
      "message": "Similar to `fmin`:\n* use `islessgreater` instead of op\u003d\u003d\n* `midpoint` for averaging to avoid overflows.",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b1f5ada_e13c1c47",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 794,
      "author": {
        "id": 5155
      },
      "writtenOn": "2022-06-08T08:15:43Z",
      "side": 1,
      "message": "I don\u0027t think this is right, operator\u003d\u003d (and operator!\u003d) should *not* set any FP exceptions, see here: https://www.gnu.org/software/libc/manual/html_node/FP-Comparison-Functions.html for example.\n\nCeres requires C++17 only, and we won\u0027t change to C++20 soon and I want a single code-path rather than conditionals for C++20",
      "parentUuid": "c520f33a_282bdfae",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21b0374a_e431b69d",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 794,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-08T10:49:15Z",
      "side": 1,
      "message": "From the link above:\n\u003e The standard C comparison operators provoke exceptions when one or other of the operands is NaN.\n\nSince we explicitly catch NaNs this of course will not happen but for consistency we should use quiet comparisons regardless.",
      "parentUuid": "2b1f5ada_e13c1c47",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d54f4ac_e3e3638c",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 794,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-08T10:58:07Z",
      "side": 1,
      "message": "Oh, you actually do not catch NaNs. My bad. So the exceptions will in fact occur.",
      "parentUuid": "21b0374a_e431b69d",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a73a97e_4c806c66",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 794,
      "author": {
        "id": 5155
      },
      "writtenOn": "2022-06-08T10:59:58Z",
      "side": 1,
      "message": "From that link: \"The standard C comparison operators provoke exceptions when one or other of the operands is NaN. For example ... will raise an exception if a is NaN. (This does not happen with \u003d\u003d and !\u003d; those merely return false and true, respectively, when NaN is examined.)\"\n\nSee the last sentence, so it is not that we are catching nan\u0027s explicitly, as we are not doing so until after this is evaluated.  I don\u0027t see any benefit over using operator\u003d\u003d here.\n\nThe tests should catch that the FE exception flags are in fact not set.  You think that they are incomplete?",
      "parentUuid": "21b0374a_e431b69d",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eba4d42e_fcf956c3",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 794,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-08T11:19:21Z",
      "side": 1,
      "message": "Yes, you are right. I oversaw the exception for the equality comparison. However, my point still stands:\n1. Consistency\n2. Compilers may raise warnings when comparing FP values using op\u003d\u003d (see `-Wfloat-equal`: https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html). This is something we should avoid.",
      "parentUuid": "6a73a97e_4c806c66",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a50ede8d_34a50225",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 809,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-07T19:52:56Z",
      "side": 1,
      "message": "op\u003d\u003d is not a quiet comparison and will set floating point exceptions. You want to use `islessgreater` or otherwise you defeat the purpose of `fmin/fmax`.",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d70c07cc_4b46bcbc",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 809,
      "author": {
        "id": 5155
      },
      "writtenOn": "2022-06-08T08:15:43Z",
      "side": 1,
      "message": "As above, operator\u003d\u003d and operator!\u003d should not set floating point exceptions, and the tests also verify this.",
      "parentUuid": "a50ede8d_34a50225",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4f26339_2bc2bbd6",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 809,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-08T10:49:15Z",
      "side": 1,
      "message": "See my previous comment.",
      "parentUuid": "d70c07cc_4b46bcbc",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d44e5a4b_8a8c0620",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 810,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-07T19:52:56Z",
      "side": 1,
      "message": "If C++20 is active, we should use `std::midpoint` which handles overflows.",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f05cad99_7b93bb9f",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 810,
      "author": {
        "id": 5155
      },
      "writtenOn": "2022-06-08T08:15:43Z",
      "side": 1,
      "message": "Ceres uses C++17, so changing this can be something for the future but not now",
      "parentUuid": "d44e5a4b_8a8c0620",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2fe83d8_5e45685d",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 810,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-08T10:49:15Z",
      "side": 1,
      "message": "Sure, Ceres defaults to C++17 but conditionally still supports C++20. In my opinion, we should invoke features depending on the active C++ dialect particularly if these affect numerical stability.",
      "parentUuid": "f05cad99_7b93bb9f",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41aaa5c6_cefea1e9",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 810,
      "author": {
        "id": 5155
      },
      "writtenOn": "2022-06-08T10:59:58Z",
      "side": 1,
      "message": "Consistency of execution paths and maintainability is valuable, whilst C++17 is our (recent) default",
      "parentUuid": "f2fe83d8_5e45685d",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b8b7c75_608f2b87",
        "filename": "include/ceres/jet.h",
        "patchSetId": 3
      },
      "lineNbr": 810,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-08T11:19:21Z",
      "side": 1,
      "message": "According to this logic we should not allow C++20 compilation then, because same execution paths are not guaranteed anymore (for instance, in the standard library.)",
      "parentUuid": "41aaa5c6_cefea1e9",
      "revId": "18dde60c433b96b351c4bb7a006649459ae86103",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}