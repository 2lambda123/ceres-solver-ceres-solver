{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d0f8662b_7f7798b7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6667
      },
      "writtenOn": "2024-05-06T22:39:32Z",
      "side": 1,
      "message": "Results of benchmarking via bundle_adjuster on BAL are available here: https://drive.google.com/file/d/1MhmtrO_e-1lU9fnd1Jy8p7Tk0est948A/view?usp\u003dsharing (problem-13682-4456117-pre is omitted due to my gpu not having enough memory - this problem requires a bit more then 8 Gb).\n\nSingle precision seems to be unstable, i did not directly compared the solutions, but i observed variations in \"cost change\" between various runs.\n\ncuDSS cmake config for windows seems to be a bit broken, hence the patching in windows.yml, although i might simply be using it in a wrong way.",
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16c66514_e98eaad5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-06T23:38:00Z",
      "side": 1,
      "message": "Mark this looks quite nice and clean and very complete. I have taken a quick first pass. There are some minor design points that are worth talking about like the new enum. I would also like sergiu to take a look at the cmake and the github workflow integration, but other than that unless I hear strong objections from the nvidia folks, I would very much like to see this checked in, and then work on improving its performance further.",
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8365f601_3ace3477",
        "filename": "CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-06T23:38:00Z",
      "side": 1,
      "message": "CUDSS -\u003e USE_CUDSS",
      "range": {
        "startLine": 109,
        "startChar": 7,
        "endLine": 109,
        "endChar": 12
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3aeb2219_027f07a5",
        "filename": "CMakeLists.txt",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 6667
      },
      "writtenOn": "2024-05-07T00:19:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8365f601_3ace3477",
      "range": {
        "startLine": 109,
        "startChar": 7,
        "endLine": 109,
        "endChar": 12
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3499f9af_ee203c39",
        "filename": "include/ceres/types.h",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-06T23:38:00Z",
      "side": 1,
      "message": "this is a bit nasty, where we have CUDA_SPARSE as well as CUDSS. Is it the case that CUDSS will eventually replace the sparse cholesky routines that ship with CUDA_SPARSE? or will CUDSS continue to be a separate library? if it is the former, then we do not need to introduce a new enum here.",
      "range": {
        "startLine": 181,
        "startChar": 5,
        "endLine": 181,
        "endChar": 13
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7ceddd5_d97dc9de",
        "filename": "include/ceres/types.h",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 6667
      },
      "writtenOn": "2024-05-07T00:19:57Z",
      "side": 1,
      "message": "\u003e or will CUDSS continue to be a separate library?\n\nMy current understanding is that this the case, but we should check this with Kirill and, in case if cuDSS will be shipped as part of CUDA distribution, then we could reuse CUDA_SPARSE.",
      "parentUuid": "3499f9af_ee203c39",
      "range": {
        "startLine": 181,
        "startChar": 5,
        "endLine": 181,
        "endChar": 13
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b226a78_9ffb6c5a",
        "filename": "include/ceres/types.h",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 3415050
      },
      "writtenOn": "2024-05-07T22:41:50Z",
      "side": 1,
      "message": "Mark is right about cuDSS vs CUDA distribution, I do see cuDSS staying a product outside of CUDA distribution [one of the reasons being our plans to go distributed which is not possible within CUDA distribution].\nAlso, we definitely want to steer the users away from sparse Cholesky from cusolverSp towards cuDSS, for better functionality and performance. I actually hope cudss can already replace the calls to sparse Cholesky from cusolverSp and be a uniformly better replacement.\nSo we can assume cuDSS remains outside CUDA and I\u0027d suggest keeping CUDSS flag separately.",
      "parentUuid": "a7ceddd5_d97dc9de",
      "range": {
        "startLine": 181,
        "startChar": 5,
        "endLine": 181,
        "endChar": 13
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22cca048_9c7b2ae7",
        "filename": "include/ceres/types.h",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-14T17:43:57Z",
      "side": 1,
      "message": "Thanks for the explanation.\n\nCurrently there is no support for cusolverSp in ceres, because in the past it was not found not to have a great API or performance compared to our CPU based backends. With the availabilty CUDSS, I suspect the chances of cusolverSp support being added are even less. \n\nSo what do you think about treating CUDA_SPARSE as a general enum which corresponds to CUDA based sparse linear algebra support in ceres? if ceres is compiled with CUDSS, the user can select this as the backend and get access to CUDSS\u0027s sparse cholesky, and if not then not. \n\nI suppose we should also account for the case where CUDSS is available bit CUDA is not available. I am assuming that is not something that should/will happen. I imagine CUDSS also depends on CUDA at least internally.\n\nOr we can demand that user must have CUDA for basic CUDA support and then CUDSS for sparse factorization support?\n\nWDYT?",
      "parentUuid": "8b226a78_9ffb6c5a",
      "range": {
        "startLine": 181,
        "startChar": 5,
        "endLine": 181,
        "endChar": 13
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4dd179ba_cebe0807",
        "filename": "include/ceres/types.h",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 3415050
      },
      "writtenOn": "2024-05-15T04:14:10Z",
      "side": 1,
      "message": "Your suspicion about cusolverSp is correct, if it is not used now, there is only a small chance that it will be used given that there is cuDSS.\ncuDSS indeed internally depends on CUDA.\nOne caveat about using CUDA_SPARSE for me is that there are sparse libraries cuSPARSE and cuSPARSELt, and as a user I\u0027d expect that CUDA_SPARSE is about using them (w/ or w/o cuDSS). E.g., what if there will be another direct sparse solver on Nvidia GPU as a cered backend? I am not sure if bundling cuSPARSE/cuSPARSELt/(cusparseDX)/cuDSS together will always remain a good idea.\n\nSo I\u0027d suggest separating basic CUDA support and CUDSS.",
      "parentUuid": "22cca048_9c7b2ae7",
      "range": {
        "startLine": 181,
        "startChar": 5,
        "endLine": 181,
        "endChar": 13
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84354aae_b8408ce8",
        "filename": "include/ceres/types.h",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-15T19:16:34Z",
      "side": 1,
      "message": "Thinking out aloud here. (I apologize for the rambling in advance).\n\nFrom a user\u0027s perspective CUDA_SPARSE and CUDSS are  nvidia\u0027s sparse math libraries, and if they have access to nvidia hardware, they just want the  fast thing that works on nvidia hardware. So I think of CUDA_SPARSE more as sparse stuff on nvidia hardware, rather than the specific packaging of libraries. In that sense, it makes for keeping this as a single enum indicating whether you want the sparse compute to happen on an nvidia GPU or not. \n\nHere is a small counter argument.\n\nWe currently have a function \n\nIsSparseLinearAlgebraLibraryTypeAvailable\n\nwhich if we only have one enum will return true if we compile with support for CUDA but not CUDSS, and then the user still has to figure out if SPARSE_CHOLESKY + CUDA_SPARSE is a valid combination or not. \n\nThe reason I think this is not a very strong argument is because even right now it is the case that sparse_linear_algebra_library_type can be CUDA_SPARSE but SPARSE_CHOLESKY is not available, and the user needs to know what is going on. \n\nI also expect gpu based sparse_cholesky (single and double precision) will actually have a bigger use case than what we have right now (CUDA_SPARSE + CGNR as the only supported solver), so once this feature becomes available I expect users to take CUDA + CUDSS as the default dependency rather than just CUDA. We can add warning to the cmakefile is CUDA is enabled by CUDSS is not that the SPARSE_CHOLESKY is not available. \n\nWe could even consider one step further, which is if USE_CUDA is enabled, then the user must have CUDA and CUDSS available.. unless it is the case that there is hardware that we want to run CUDA based iterative solvers on and CUDSS is not available. Or only an older version of CUDA is available -- I think this is actually the case. \n\nLet me add joydeep to this CL, he is the one who initially added cuda support to ceres and is one of the users who has a sense of the landscape.",
      "parentUuid": "4dd179ba_cebe0807",
      "range": {
        "startLine": 181,
        "startChar": 5,
        "endLine": 181,
        "endChar": 13
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2292013_505a033a",
        "filename": "include/ceres/types.h",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 5135
      },
      "writtenOn": "2024-05-15T19:56:11Z",
      "side": 1,
      "message": "Currently, CUDA_SPARSE only affects CGNR, where cuSPARSE is used.\n\nI think from a user standpoint, the details of which parts of the CUDA library are used are not as important - I agree with Sameer that the user will just want the library to select the best option in the library selected.\n\nI think it would be good to simplify as follows:\n- Have a single CUDA_SPARSE option.\n- When SPARSE_NORMAL_CHOLESKY or SPARSE_SCHUR is selected, this should use the new cuDSS library. \n- When CGNR is selected, it should use the existing cuSPARSE CGNR implementation (unless cuDSS has something that\u0027s faster).\n\nIn CMakeLists.txt, I propose the following:\nIf USE_CUDA is enabled but cuDSS is not found, it should enable two things:\n1. A warning during build that cuDSS was not found, so CUDA sparse direct solvers are disabled\n2. An error message in the magical `OptionsAreValidForSparseCholeskyBasedSolver`  and `OptionsAreValidForSparseNormalCholesky` functions that says the same things at runtime when CUDA_SPARSE is selected but cuDSS was not found at compile time.",
      "parentUuid": "84354aae_b8408ce8",
      "range": {
        "startLine": 181,
        "startChar": 5,
        "endLine": 181,
        "endChar": 13
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99fd59ac_f8e6d50f",
        "filename": "include/ceres/types.h",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-15T20:45:41Z",
      "side": 1,
      "message": "Thanks Joydeep. \nLets go with this.\nWe already have Options::IsValid, we should enhance that checking.",
      "parentUuid": "e2292013_505a033a",
      "range": {
        "startLine": 181,
        "startChar": 5,
        "endLine": 181,
        "endChar": 13
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f00ffa73_4e228395",
        "filename": "include/ceres/types.h",
        "patchSetId": 1
      },
      "lineNbr": 181,
      "author": {
        "id": 6667
      },
      "writtenOn": "2024-05-16T01:22:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "99fd59ac_f8e6d50f",
      "range": {
        "startLine": 181,
        "startChar": 5,
        "endLine": 181,
        "endChar": 13
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "146c2597_38d264a9",
        "filename": "include/ceres/version.h",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-06T23:38:00Z",
      "side": 1,
      "message": "this change seems independent of this CL no? want to send it to me separately?",
      "range": {
        "startLine": 44,
        "startChar": 8,
        "endLine": 44,
        "endChar": 28
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19bf92cf_761b27a0",
        "filename": "include/ceres/version.h",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 6667
      },
      "writtenOn": "2024-05-07T00:19:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "146c2597_38d264a9",
      "range": {
        "startLine": 44,
        "startChar": 8,
        "endLine": 44,
        "endChar": 28
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e66e9a12_50ffaf36",
        "filename": "internal/ceres/cuda_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 170,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-06T23:38:00Z",
      "side": 1,
      "message": "class documentation. When should the user use this vs just CudaBuffer.\n\nalso I have this vague recollection that there is a pinned buffer elsewere in the codebase that dmitriy added, or is in the process of adding.",
      "range": {
        "startLine": 170,
        "startChar": 6,
        "endLine": 170,
        "endChar": 26
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82e1e867_ff0f74bd",
        "filename": "internal/ceres/cuda_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 170,
      "author": {
        "id": 6667
      },
      "writtenOn": "2024-05-07T00:19:57Z",
      "side": 1,
      "message": "\u003e also I have this vague recollection that there is a pinned buffer elsewere in the codebase that dmitriy added\n\nI failed to find such structure in current codebase and in currently opened PR\u0027s.",
      "parentUuid": "e66e9a12_50ffaf36",
      "range": {
        "startLine": 170,
        "startChar": 6,
        "endLine": 170,
        "endChar": 26
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19c8652a_b1791b62",
        "filename": "internal/ceres/cuda_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 170,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-14T17:43:57Z",
      "side": 1,
      "message": "I was thinking about the mapped memory support for CudaBuffer. See \n\nhttps://ceres-solver-review.git.corp.google.com/c/ceres-solver/+/25740/1/internal/ceres/cuda_buffer.h",
      "parentUuid": "82e1e867_ff0f74bd",
      "range": {
        "startLine": 170,
        "startChar": 6,
        "endLine": 170,
        "endChar": 26
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0436b8bc_a4ab7a61",
        "filename": "internal/ceres/cuda_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 170,
      "author": {
        "id": 5135
      },
      "writtenOn": "2024-05-15T19:56:11Z",
      "side": 1,
      "message": "Public link: https://ceres-solver-review.googlesource.com/c/ceres-solver/+/25740/1/internal/ceres/cuda_buffer.h\n\n+1 to using pinned memory, and using CudaBuffer.",
      "parentUuid": "19c8652a_b1791b62",
      "range": {
        "startLine": 170,
        "startChar": 6,
        "endLine": 170,
        "endChar": 26
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2121b26b_0af4c569",
        "filename": "internal/ceres/cuda_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 170,
      "author": {
        "id": 6667
      },
      "writtenOn": "2024-05-16T01:22:01Z",
      "side": 1,
      "message": "Currently, CudaBuffer is managing a region of memory that resides on device (allocated via cudaMalloc() and released via cudaFree()). In pr that you referred a change introduced to enable CudaBuffer to act as a non-owning wrapper over user provided device pointer.\n\nThe CudaPinnedHostBuffer introduced here is a struct to manage (in RAII fashion) a region of \"pinned\" memory that resides in host memory (allocated via cudaMallocHost() and released via cudaFreeHost()), so i don\u0027t see how we could simplify things by using CudaBuffer for that.\n\nMy suggesting on that topic would be to rename CudaBuffer -\u003e CudaDeviceBuffer in order to express such class semantics a bit more clear.",
      "parentUuid": "19c8652a_b1791b62",
      "range": {
        "startLine": 170,
        "startChar": 6,
        "endLine": 170,
        "endChar": 26
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b34d097_501a0ee4",
        "filename": "internal/ceres/cuda_sparse_matrix.cc",
        "patchSetId": 1
      },
      "lineNbr": 59,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-06T23:38:00Z",
      "side": 1,
      "message": "this seems to be independent of this CL.",
      "range": {
        "startLine": 59,
        "startChar": 7,
        "endLine": 59,
        "endChar": 8
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "513b9afd_01ba48cb",
        "filename": "internal/ceres/cuda_sparse_matrix.cc",
        "patchSetId": 1
      },
      "lineNbr": 59,
      "author": {
        "id": 6667
      },
      "writtenOn": "2024-05-07T00:19:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8b34d097_501a0ee4",
      "range": {
        "startLine": 59,
        "startChar": 7,
        "endLine": 59,
        "endChar": 8
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f9c1c92a_7be3f49a",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 1
      },
      "lineNbr": 692,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-06T23:38:00Z",
      "side": 1,
      "message": "this is what I meant when I was talking about the new enum, we could just stick to using CUDA_SPARSE as the enum, but only support sparse cholesky if CUDSS was available.",
      "range": {
        "startLine": 692,
        "startChar": 58,
        "endLine": 692,
        "endChar": 63
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad27640e_7d37879a",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 1
      },
      "lineNbr": 692,
      "author": {
        "id": 3415050
      },
      "writtenOn": "2024-05-15T04:14:10Z",
      "side": 1,
      "message": "I\u0027d weakly suggest to keep the logic within ceres simple and avoid implicit assumptions which might confuse the users. But you have definitely a better view of the entire picture here.",
      "parentUuid": "f9c1c92a_7be3f49a",
      "range": {
        "startLine": 692,
        "startChar": 58,
        "endLine": 692,
        "endChar": 63
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8f4e033_90017e2a",
        "filename": "internal/ceres/solver_utils.cc",
        "patchSetId": 1
      },
      "lineNbr": 49,
      "author": {
        "id": 5002
      },
      "writtenOn": "2024-05-06T23:38:00Z",
      "side": 1,
      "message": "please send me this change separate from this CL.",
      "range": {
        "startLine": 49,
        "startChar": 2,
        "endLine": 49,
        "endChar": 22
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3dc787fe_4c567c85",
        "filename": "internal/ceres/solver_utils.cc",
        "patchSetId": 1
      },
      "lineNbr": 49,
      "author": {
        "id": 6667
      },
      "writtenOn": "2024-05-07T00:19:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b8f4e033_90017e2a",
      "range": {
        "startLine": 49,
        "startChar": 2,
        "endLine": 49,
        "endChar": 22
      },
      "revId": "7ff6aceab66522e4eb18f20590c9a52119a009a6",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}