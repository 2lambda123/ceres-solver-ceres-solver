
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    

    <title>Modeling API &mdash; Ceres Solver</title>

<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;"/>


    
    <link rel="stylesheet" href="_static/rtd.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
  MathJax.Hub.Config({
    "HTML-CSS": {
      availableFonts: ["TeX"]
    }
  });
</script>
    <script type="text/javascript" src="_static/searchtools.js"></script>
    <link rel="top" title="Ceres Solver" href="index.html" />
    <link rel="next" title="Solver API" href="solving.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="solving.html" title="Solver API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Ceres Solver</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="modeling-api">
<span id="chapter-modeling"></span><h1>Modeling API<a class="headerlink" href="#modeling-api" title="Permalink to this headline">¶</a></h1>
<p>Recall that Ceres solves robustified non-linear least squares problems
of the form</p>
<div class="math" id="equation-ceresproblem3">
<span class="eqno">(1)</span>\[\frac{1}{2}\sum_{i=1} \rho_i\left(\left\|f_i\left(x_{i_1}, ... ,x_{i_k}\right)\right\|^2\right).\]</div>
<p>The expression
<span class="math">\(\rho_i\left(\left\|f_i\left(x_{i_1},...,x_{i_k}\right)\right\|^2\right)\)</span>
is known as a <tt class="docutils literal"><span class="pre">ResidualBlock</span></tt>, where <span class="math">\(f_i(\cdot)\)</span> is a
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> that depends on the parameter blocks
<span class="math">\(\left[x_{i_1},... , x_{i_k}\right]\)</span>. In most optimization
problems small groups of scalars occur together. For example the three
components of a translation vector and the four components of the
quaternion that define the pose of a camera. We refer to such a group
of small scalars as a <tt class="docutils literal"><span class="pre">ParameterBlock</span></tt>. Of course a
<tt class="docutils literal"><span class="pre">ParameterBlock</span></tt> can just be a single parameter. <span class="math">\(\rho_i\)</span> is a
<a class="reference internal" href="#LossFunction" title="LossFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></tt></a>. A <a class="reference internal" href="#LossFunction" title="LossFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></tt></a> is a scalar function
that is used to reduce the influence of outliers on the solution of
non-linear least squares problems.</p>
<p>In this chapter we will describe the various classes that are part of
Ceres Solver&#8217;s modeling API, and how they can be used to construct
optimization.</p>
<p>Once a problem has been constructed, various methods for solving them
will be discussed in <a class="reference internal" href="solving.html#chapter-solving"><em>Solver API</em></a>. It is by design that the
modeling and the solving APIs are orthogonal to each other. This
enables easy switching/tweaking of various solver parameters without
having to touch the problem once it has been successfuly modeling.</p>
<div class="section" id="costfunction">
<h2><a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a><a class="headerlink" href="#costfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="CostFunction">
<em class="property">class </em><tt class="descname">CostFunction</tt><a class="headerlink" href="#CostFunction" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CostFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int16</span><span class="o">&gt;&amp;</span> <span class="n">parameter_block_sizes</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">num_residuals</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

 <span class="k">protected</span><span class="o">:</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">int16</span><span class="o">&gt;*</span> <span class="n">mutable_parameter_block_sizes</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">set_num_residuals</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_residuals</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Given parameter blocks <span class="math">\(\left[x_{i_1}, ... , x_{i_k}\right]\)</span>,
a <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> is responsible for computing a vector of
residuals and if asked a vector of Jacobian matrices, i.e., given
<span class="math">\(\left[x_{i_1}, ... , x_{i_k}\right]\)</span>, compute the vector
<span class="math">\(f_i\left(x_{i_1},...,x_{i_k}\right)\)</span> and the matrices</p>
<div class="math">
\[J_{ij} = \frac{\partial}{\partial x_{i_j}}f_i\left(x_{i_1},...,x_{i_k}\right),\quad \forall j \in \{i_1,..., i_k\}\]</div>
<p>The signature of the class:<cite>CostFunction</cite> (number and sizes of
input parameter blocks and number of outputs) is stored in
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt> and
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::num_residuals_</span></tt> respectively. User code
inheriting from this class is expected to set these two members
with the corresponding accessors. This information will be verified
by the <a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a> when added with
<a class="reference internal" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Problem::AddResidualBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="CostFunction::Evaluate__doubleCPCP.doubleP.doublePP">
bool <tt class="descclassname">CostFunction::</tt><tt class="descname">Evaluate</tt><big>(</big>double const* const* <em>parameters</em>, double* <em>residuals</em>, double** <em>jacobians</em><big>)</big><a class="headerlink" href="#CostFunction::Evaluate__doubleCPCP.doubleP.doublePP" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the key methods. It implements the residual and Jacobian
computation.</p>
<p><tt class="docutils literal"><span class="pre">parameters</span></tt> is an array of pointers to arrays containing the
various parameter blocks. parameters has the same number of
elements as <tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt>.
Parameter blocks are in the same order as
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">residuals</span></tt> is an array of size <tt class="docutils literal"><span class="pre">num_residuals_</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">jacobians</span></tt> is an array of size
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt> containing pointers
to storage for Jacobian matrices corresponding to each parameter
block. The Jacobian matrices are in the same order as
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt>. <tt class="docutils literal"><span class="pre">jacobians[i]</span></tt> is
an array that contains <tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::num_residuals_</span></tt> x
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt> <tt class="docutils literal"><span class="pre">[i]</span></tt>
elements. Each Jacobian matrix is stored in row-major order, i.e.,
<tt class="docutils literal"><span class="pre">jacobians[i][r</span> <span class="pre">*</span> <span class="pre">parameter_block_size_[i]</span> <span class="pre">+</span> <span class="pre">c]</span></tt> =
<span class="math">\(\frac{\partial residual[r]}{\partial parameters[i][c]}\)</span></p>
<p>If <tt class="docutils literal"><span class="pre">jacobians</span></tt> is <tt class="docutils literal"><span class="pre">NULL</span></tt>, then no derivatives are returned;
this is the case when computing cost only. If <tt class="docutils literal"><span class="pre">jacobians[i]</span></tt> is
<tt class="docutils literal"><span class="pre">NULL</span></tt>, then the Jacobian matrix corresponding to the
<span class="math">\(i^{\textrm{th}}\)</span> parameter block must not be returned, this
is the case when the a parameter block is marked constant.</p>
</dd></dl>

</div>
<div class="section" id="sizedcostfunction">
<h2><a class="reference internal" href="#SizedCostFunction" title="SizedCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">SizedCostFunction</span></tt></a><a class="headerlink" href="#sizedcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="SizedCostFunction">
<em class="property">class </em><tt class="descname">SizedCostFunction</tt><a class="headerlink" href="#SizedCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>If the size of the parameter blocks and the size of the residual
vector is known at compile time (this is the common case), Ceres
provides <a class="reference internal" href="#SizedCostFunction" title="SizedCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">SizedCostFunction</span></tt></a>, where these values can be
specified as template parameters. In this case the user only needs
to implement the <a class="reference internal" href="#CostFunction::Evaluate__doubleCPCP.doubleP.doublePP" title="CostFunction::Evaluate"><tt class="xref cpp cpp-func docutils literal"><span class="pre">CostFunction::Evaluate()</span></tt></a>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">kNumResiduals</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">N0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">N5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N9</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SizedCostFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="autodiffcostfunction">
<h2><a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a><a class="headerlink" href="#autodiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="AutoDiffCostFunction">
<em class="property">class </em><tt class="descname">AutoDiffCostFunction</tt><a class="headerlink" href="#AutoDiffCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>But even defining the <a class="reference internal" href="#SizedCostFunction" title="SizedCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">SizedCostFunction</span></tt></a> can be a tedious
affair if complicated derivative computations are involved. To this
end Ceres provides automatic differentiation.</p>
<p>To get an auto differentiated cost function, you must define a
class with a templated <tt class="docutils literal"><span class="pre">operator()</span></tt> (a functor) that computes the
cost function in terms of the template parameter <tt class="docutils literal"><span class="pre">T</span></tt>. The
autodiff framework substitutes appropriate <tt class="docutils literal"><span class="pre">Jet</span></tt> objects for
<tt class="docutils literal"><span class="pre">T</span></tt> in order to compute the derivative when necessary, but this
is hidden, and you should write the function as if <tt class="docutils literal"><span class="pre">T</span></tt> were a
scalar type (e.g. a double-precision floating point number).</p>
<p>The function must write the computed value in the last argument
(the only non-<tt class="docutils literal"><span class="pre">const</span></tt> one) and return true to indicate success.</p>
<p>For example, consider a scalar error <span class="math">\(e = k - x^\top y\)</span>,
where both <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are two-dimensional vector
parameters and <span class="math">\(k\)</span> is a constant. The form of this error,
which is the difference between a constant and an expression, is a
common pattern in least squares problems. For example, the value
<span class="math">\(x^\top y\)</span> might be the model expectation for a series of
measurements, where there is an instance of the cost function for
each measurement <span class="math">\(k\)</span>.</p>
<p>The actual cost added to the total problem is <span class="math">\(e^2\)</span>, or
<span class="math">\((k - x^\top y)^2\)</span>; however, the squaring is implicitly done
by the optimization framework.</p>
<p>To write an auto-differentiable cost function for the above model,
first define the object</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyScalarCostFunctor</span> <span class="p">{</span>
  <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="kt">double</span> <span class="n">k</span><span class="p">)</span><span class="o">:</span> <span class="n">k_</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span> <span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">y</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">k_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that in the declaration of <tt class="docutils literal"><span class="pre">operator()</span></tt> the input parameters
<tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> come first, and are passed as const pointers to arrays
of <tt class="docutils literal"><span class="pre">T</span></tt>. If there were three input parameters, then the third input
parameter would come after <tt class="docutils literal"><span class="pre">y</span></tt>. The output is always the last
parameter, and is also a pointer to an array. In the example above,
<tt class="docutils literal"><span class="pre">e</span></tt> is a scalar, so only <tt class="docutils literal"><span class="pre">e[0]</span></tt> is set.</p>
<p>Then given this class definition, the auto differentiated cost
function for it can be constructed as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>              <span class="o">^</span>  <span class="o">^</span>  <span class="o">^</span>
                                                    <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
                        <span class="n">Dimension</span> <span class="n">of</span> <span class="n">residual</span> <span class="o">------+</span>  <span class="o">|</span>  <span class="o">|</span>
                        <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">----------------+</span>  <span class="o">|</span>
                        <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">-------------------+</span>
</pre></div>
</div>
<p>In this example, there is usually an instance for each measurement
of <tt class="docutils literal"><span class="pre">k</span></tt>.</p>
<p>In the instantiation above, the template parameters following
<tt class="docutils literal"><span class="pre">MyScalarCostFunction</span></tt>, <tt class="docutils literal"><span class="pre">&lt;1,</span> <span class="pre">2,</span> <span class="pre">2&gt;</span></tt> describe the functor as
computing a 1-dimensional output from two arguments, both
2-dimensional.</p>
<p>The framework can currently accommodate cost functions of up to 6
independent variables, and there is no limit on the dimensionality of
each of them.</p>
<p><strong>WARNING 1</strong> Since the functor will get instantiated with
different types for <tt class="docutils literal"><span class="pre">T</span></tt>, you must convert from other numeric
types to <tt class="docutils literal"><span class="pre">T</span></tt> before mixing computations with other variables
oftype <tt class="docutils literal"><span class="pre">T</span></tt>. In the example above, this is seen where instead of
using <tt class="docutils literal"><span class="pre">k_</span></tt> directly, <tt class="docutils literal"><span class="pre">k_</span></tt> is wrapped with <tt class="docutils literal"><span class="pre">T(k_)</span></tt>.</p>
<p><strong>WARNING 2</strong> A common beginner&#8217;s error when first using
<a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a> is to get the sizing wrong. In particular,
there is a tendency to set the template parameters to (dimension of
residual, number of parameters) instead of passing a dimension
parameter for <em>every parameter block</em>. In the example above, that
would be <tt class="docutils literal"><span class="pre">&lt;MyScalarCostFunction,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></tt>, which is missing the 2
as the last template argument.</p>
</dd></dl>

</div>
<div class="section" id="numericdiffcostfunction">
<h2><a class="reference internal" href="#NumericDiffCostFunction" title="NumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></tt></a><a class="headerlink" href="#numericdiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="NumericDiffCostFunction">
<em class="property">class </em><tt class="descname">NumericDiffCostFunction</tt><a class="headerlink" href="#NumericDiffCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CostFunctionNoJacobian</span><span class="p">,</span>
          <span class="n">NumericDiffMethod</span> <span class="n">method</span> <span class="o">=</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">N0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">N5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N9</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">NumericDiffCostFunction</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">SizedCostFunction</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span> <span class="n">N0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">,</span> <span class="n">N4</span><span class="p">,</span> <span class="n">N5</span><span class="p">,</span> <span class="n">N6</span><span class="p">,</span> <span class="n">N7</span><span class="p">,</span> <span class="n">N8</span><span class="p">,</span> <span class="n">N9</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Create a <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> as needed by the least squares
framework with jacobians computed via numeric (a.k.a. finite)
differentiation. For more details see
<a class="reference external" href="http://en.wikipedia.org/wiki/Numerical_differentiation">http://en.wikipedia.org/wiki/Numerical_differentiation</a>.</p>
<p>To get an numerically differentiated <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a>, you
must define a class with a <tt class="docutils literal"><span class="pre">operator()</span></tt> (a functor) that computes
the residuals. The functor must write the computed value in the
last argument (the only non-<tt class="docutils literal"><span class="pre">const</span></tt> one) and return <tt class="docutils literal"><span class="pre">true</span></tt> to
indicate success. e.g., an object of the form</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">ScalarFunctor</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x1</span><span class="p">,</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x2</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For example, consider a scalar error <span class="math">\(e = k - x'y\)</span>, where
both <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are two-dimensional column vector
parameters, the prime sign indicates transposition, and <span class="math">\(k\)</span>
is a constant. The form of this error, which is the difference
between a constant and an expression, is a common pattern in least
squares problems. For example, the value <span class="math">\(x'y\)</span> might be the
model expectation for a series of measurements, where there is an
instance of the cost function for each measurement <span class="math">\(k\)</span>.</p>
<p>To write an numerically-differentiable class:<cite>CostFunction</cite> for the
above model, first define the object</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyScalarCostFunctor</span> <span class="p">{</span>
  <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="kt">double</span> <span class="n">k</span><span class="p">)</span><span class="o">:</span> <span class="n">k_</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">y</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">k_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that in the declaration of <tt class="docutils literal"><span class="pre">operator()</span></tt> the input parameters
<tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> come first, and are passed as const pointers to
arrays of <tt class="docutils literal"><span class="pre">double</span></tt> s. If there were three input parameters, then
the third input parameter would come after <tt class="docutils literal"><span class="pre">y</span></tt>. The output is
always the last parameter, and is also a pointer to an array. In
the example above, the residual is a scalar, so only
<tt class="docutils literal"><span class="pre">residuals[0]</span></tt> is set.</p>
<p>Then given this class definition, the numerically differentiated
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> with central differences used for computing
the derivative can be constructed as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>                          <span class="o">^</span>  <span class="o">^</span>  <span class="o">^</span>
                                                            <span class="o">|</span>   <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
                                <span class="n">Finite</span> <span class="n">Differencing</span> <span class="n">Scheme</span> <span class="o">-+</span>   <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
                                <span class="n">Dimension</span> <span class="n">of</span> <span class="n">residual</span> <span class="o">----------+</span>  <span class="o">|</span>  <span class="o">|</span>
                                <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">--------------------+</span>  <span class="o">|</span>
                                <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">-----------------------+</span>
</pre></div>
</div>
<p>In this example, there is usually an instance for each measumerent of <cite>k</cite>.</p>
<p>In the instantiation above, the template parameters following
<tt class="docutils literal"><span class="pre">MyScalarCostFunctor</span></tt>, <tt class="docutils literal"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">2</span></tt>, describe the functor as
computing a 1-dimensional output from two arguments, both
2-dimensional.</p>
<p>The framework can currently accommodate cost functions of up to 10
independent variables, and there is no limit on the dimensionality
of each of them.</p>
<p>The <tt class="docutils literal"><span class="pre">CENTRAL</span></tt> difference method is considerably more accurate at
the cost of twice as many function evaluations than forward
difference. Consider using central differences begin with, and only
after that works, trying forward difference to improve performance.</p>
<p><strong>WARNING</strong> A common beginner&#8217;s error when first using
NumericDiffCostFunction is to get the sizing wrong. In particular,
there is a tendency to set the template parameters to (dimension of
residual, number of parameters) instead of passing a dimension
parameter for <em>every parameter</em>. In the example above, that would
be <tt class="docutils literal"><span class="pre">&lt;MyScalarCostFunctor,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></tt>, which is missing the last <tt class="docutils literal"><span class="pre">2</span></tt>
argument. Please be careful when setting the size parameters.</p>
<p><strong>Alternate Interface</strong></p>
<p>For a variety of reason, including compatibility with legacy code,
<a class="reference internal" href="#NumericDiffCostFunction" title="NumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></tt></a> can also take
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> objects as input. The following describes
how.</p>
<p>To get a numerically differentiated cost function, define a
subclass of <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> such that the
<a class="reference internal" href="#CostFunction::Evaluate__doubleCPCP.doubleP.doublePP" title="CostFunction::Evaluate"><tt class="xref cpp cpp-func docutils literal"><span class="pre">CostFunction::Evaluate()</span></tt></a> function ignores the <tt class="docutils literal"><span class="pre">jacobians</span></tt>
parameter. The numeric differentiation wrapper will fill in the
jacobian parameter if nececssary by repeatedly calling the
<a class="reference internal" href="#CostFunction::Evaluate__doubleCPCP.doubleP.doublePP" title="CostFunction::Evaluate"><tt class="xref cpp cpp-func docutils literal"><span class="pre">CostFunction::Evaluate()</span></tt></a> with small changes to the
appropriate parameters, and computing the slope. For performance,
the numeric differentiation wrapper class is templated on the
concrete cost function, even though it could be implemented only in
terms of the <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> interface.</p>
<p>The numerically differentiated version of a cost function for a
cost function can be constructed as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyCostFunction</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">MyCostFunction</span><span class="p">(...),</span> <span class="n">TAKE_OWNERSHIP</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">MyCostFunction</span></tt> has 1 residual and 2 parameter blocks with
sizes 4 and 8 respectively. Look at the tests for a more detailed
example.</p>
</dd></dl>

</div>
<div class="section" id="normalprior">
<h2><a class="reference internal" href="#NormalPrior" title="NormalPrior"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NormalPrior</span></tt></a><a class="headerlink" href="#normalprior" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="NormalPrior">
<em class="property">class </em><tt class="descname">NormalPrior</tt><a class="headerlink" href="#NormalPrior" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NormalPrior</span><span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Check that the number of rows in the vector b are the same as the</span>
  <span class="c1">// number of columns in the matrix A, crash otherwise.</span>
  <span class="n">NormalPrior</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
 <span class="p">};</span>
</pre></div>
</div>
<p>Implements a cost function of the form</p>
<div class="math">
\[cost(x) = ||A(x - b)||^2\]</div>
<p>where, the matrix A and the vector b are fixed and x is the
variable. In case the user is interested in implementing a cost
function of the form</p>
</div></blockquote>
<div class="math">
\[cost(x) = (x - \mu)^T S^{-1} (x - \mu)\]</div>
<p>where, <span class="math">\(\mu\)</span> is a vector and <span class="math">\(S\)</span> is a covariance matrix,
then, <span class="math">\(A = S^{-1/2}\)</span>, i.e the matrix <span class="math">\(A\)</span> is the square
root of the inverse of the covariance, also known as the stiffness
matrix. There are however no restrictions on the shape of
<span class="math">\(A\)</span>. It is free to be rectangular, which would be the case if
the covariance matrix <span class="math">\(S\)</span> is rank deficient.</p>
</dd></dl>

</div>
<div class="section" id="conditionedcostfunction">
<h2><a class="reference internal" href="#ConditionedCostFunction" title="ConditionedCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ConditionedCostFunction</span></tt></a><a class="headerlink" href="#conditionedcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ConditionedCostFunction">
<em class="property">class </em><tt class="descname">ConditionedCostFunction</tt><a class="headerlink" href="#ConditionedCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>This class allows you to apply different conditioning to the residual
values of a wrapped cost function. An example where this is useful is
where you have an existing cost function that produces N values, but you
want the total cost to be something other than just the sum of these
squared values - maybe you want to apply a different scaling to some
values, to change their contribution to the cost.</p>
<p>Usage:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  my_cost_function produces N residuals</span>
<span class="n">CostFunction</span><span class="o">*</span> <span class="n">my_cost_function</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">CHECK_EQ</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">my_cost_function</span><span class="o">-&gt;</span><span class="n">num_residuals</span><span class="p">());</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">CostFunction</span><span class="o">*&gt;</span> <span class="n">conditioners</span><span class="p">;</span>

<span class="c1">//  Make N 1x1 cost functions (1 parameter, 1 residual)</span>
<span class="n">CostFunction</span><span class="o">*</span> <span class="n">f_1</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">conditioners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">f_1</span><span class="p">);</span>

<span class="n">CostFunction</span><span class="o">*</span> <span class="n">f_N</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">conditioners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">f_N</span><span class="p">);</span>
<span class="n">ConditionedCostFunction</span><span class="o">*</span> <span class="n">ccf</span> <span class="o">=</span>
  <span class="k">new</span> <span class="n">ConditionedCostFunction</span><span class="p">(</span><span class="n">my_cost_function</span><span class="p">,</span> <span class="n">conditioners</span><span class="p">);</span>
</pre></div>
</div>
<p>Now <tt class="docutils literal"><span class="pre">ccf</span></tt> &#8216;s <tt class="docutils literal"><span class="pre">residual[i]</span></tt> (i=0..N-1) will be passed though the
<span class="math">\(i^{\text{th}}\)</span> conditioner.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ccf_residual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_i</span><span class="p">(</span><span class="n">my_cost_function_residual</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>and the Jacobian will be affected appropriately.</p>
</dd></dl>

</div>
<div class="section" id="costfunctiontofunctor">
<h2><a class="reference internal" href="#CostFunctionToFunctor" title="CostFunctionToFunctor"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></tt></a><a class="headerlink" href="#costfunctiontofunctor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="CostFunctionToFunctor">
<em class="property">class </em><tt class="descname">CostFunctionToFunctor</tt><a class="headerlink" href="#CostFunctionToFunctor" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#CostFunctionToFunctor" title="CostFunctionToFunctor"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></tt></a> is an adapter class that allows users to use
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> objects in templated functors which are to be used for
automatic differentiation.  This allows the user to seamlessly mix
analytic, numeric and automatic differentiation.</p>
<p>For example, let us assume that</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">IntrinsicProjection</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SizedCostFunction</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">observations</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                          <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                          <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>is a <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> that implements the projection of a
point in its local coordinate system onto its image plane and
subtracts it from the observed point projection. It can compute its
residual and either via analytic or numerical differentiation can
compute its jacobians.</p>
<p>Now we would like to compose the action of this
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> with the action of camera extrinsics, i.e.,
rotation and translation. Say we have a templated function</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                             <span class="n">T</span><span class="o">*</span> <span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>Then we can now do the following,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">CameraProjection</span> <span class="p">{</span>
  <span class="n">CameraProjection</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">intrinsic_projection_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">CostFunctionToFunctor</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="n">observation_</span><span class="p">)));</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">intrinsics</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                <span class="n">T</span><span class="o">*</span> <span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">transformed_point</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">);</span>

    <span class="c1">//   Note that we call intrinsic_projection_, just like it was</span>
    <span class="c1">//   any other templated functor.</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">intrinsic_projection_</span><span class="p">)(</span><span class="n">intrinsics</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">CostFunctionToFunctor</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">intrinsic_projection_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="numericdifffunctor">
<h2><a class="reference internal" href="#NumericDiffFunctor" title="NumericDiffFunctor"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffFunctor</span></tt></a><a class="headerlink" href="#numericdifffunctor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="NumericDiffFunctor">
<em class="property">class </em><tt class="descname">NumericDiffFunctor</tt><a class="headerlink" href="#NumericDiffFunctor" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper class that takes a variadic functor evaluating a
function, numerically differentiates it and makes it available as a
templated functor so that it can be easily used as part of Ceres&#8217;
automatic differentiation framework.</p>
<p>For example, let us assume that</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">IntrinsicProjection</span>
  <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">observations</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">calibration</span><span class="p">,</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>is a functor that implements the projection of a point in its local
coordinate system onto its image plane and subtracts it from the
observed point projection.</p>
<p>Now we would like to compose the action of this functor with the
action of camera extrinsics, i.e., rotation and translation, which
is given by the following templated function</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                             <span class="n">T</span><span class="o">*</span> <span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>To compose the extrinsics and intrinsics, we can construct a
<tt class="docutils literal"><span class="pre">CameraProjection</span></tt> functor as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">CameraProjection</span> <span class="p">{</span>
   <span class="k">typedef</span> <span class="n">NumericDiffFunctor</span><span class="o">&lt;</span><span class="n">IntrinsicProjection</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span>
      <span class="n">IntrinsicProjectionFunctor</span><span class="p">;</span>

  <span class="n">CameraProjection</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">intrinsic_projection_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">IntrinsicProjectionFunctor</span><span class="p">(</span><span class="n">observation</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">intrinsics</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                <span class="n">T</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">transformed_point</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">intrinsic_projection_</span><span class="p">)(</span><span class="n">intrinsics</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">IntrinsicProjectionFunctor</span><span class="o">&gt;</span> <span class="n">intrinsic_projection_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, we made the choice of using <tt class="docutils literal"><span class="pre">CENTRAL</span></tt> differences to compute
the jacobian of <tt class="docutils literal"><span class="pre">IntrinsicProjection</span></tt>.</p>
<p>Now, we are ready to construct an automatically differentiated cost
function as</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">CameraProjection</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span>
       <span class="k">new</span> <span class="n">CameraProjection</span><span class="p">(</span><span class="n">observations</span><span class="p">));</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">cost_function</span></tt> now seamlessly integrates automatic
differentiation of <tt class="docutils literal"><span class="pre">RotateAndTranslatePoint</span></tt> with a numerically
differentiated version of <tt class="docutils literal"><span class="pre">IntrinsicProjection</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="lossfunction">
<h2><a class="reference internal" href="#LossFunction" title="LossFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></tt></a><a class="headerlink" href="#lossfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LossFunction">
<em class="property">class </em><tt class="descname">LossFunction</tt><a class="headerlink" href="#LossFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>For least squares problems where the minimization may encounter
input terms that contain outliers, that is, completely bogus
measurements, it is important to use a loss function that reduces
their influence.</p>
<p>Consider a structure from motion problem. The unknowns are 3D
points and camera parameters, and the measurements are image
coordinates describing the expected reprojected position for a
point in a camera. For example, we want to model the geometry of a
street scene with fire hydrants and cars, observed by a moving
camera with unknown parameters, and the only 3D points we care
about are the pointy tippy-tops of the fire hydrants. Our magic
image processing algorithm, which is responsible for producing the
measurements that are input to Ceres, has found and matched all
such tippy-tops in all image frames, except that in one of the
frame it mistook a car&#8217;s headlight for a hydrant. If we didn&#8217;t do
anything special the residual for the erroneous measurement will
result in the entire solution getting pulled away from the optimum
to reduce the large error that would otherwise be attributed to the
wrong measurement.</p>
<p>Using a robust loss function, the cost for large residuals is
reduced. In the example above, this leads to outlier terms getting
down-weighted so they do not overly influence the final solution.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LossFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The key method is <tt class="xref cpp cpp-func docutils literal"><span class="pre">LossFunction::Evaluate()</span></tt>, which given a
non-negative scalar <tt class="docutils literal"><span class="pre">s</span></tt>, computes</p>
<div class="math">
\[\begin{split}out = \begin{bmatrix}\rho(s), &amp; \rho'(s), &amp; \rho''(s)\end{bmatrix}\end{split}\]</div>
<p>Here the convention is that the contribution of a term to the cost
function is given by <span class="math">\(\frac{1}{2}\rho(s)\)</span>, where <span class="math">\(s
=\|f_i\|^2\)</span>. Calling the method with a negative value of <span class="math">\(s\)</span>
is an error and the implementations are not required to handle that
case.</p>
<p>Most sane choices of <span class="math">\(\rho\)</span> satisfy:</p>
<div class="math">
\[\begin{split}\rho(0) &amp;= 0\\
\rho'(0) &amp;= 1\\
\rho'(s) &amp;&lt; 1 \text{ in the outlier region}\\
\rho''(s) &amp;&lt; 0 \text{ in the outlier region}\end{split}\]</div>
<p>so that they mimic the squared cost for small residuals.</p>
<p><strong>Scaling</strong></p>
<p>Given one robustifier <span class="math">\(\rho(s)\)</span> one can change the length
scale at which robustification takes place, by adding a scale
factor <span class="math">\(a &gt; 0\)</span> which gives us <span class="math">\(\rho(s,a) = a^2 \rho(s /
a^2)\)</span> and the first and second derivatives as <span class="math">\(\rho'(s /
a^2)\)</span> and <span class="math">\((1 / a^2) \rho''(s / a^2)\)</span> respectively.</p>
<p>The reason for the appearance of squaring is that <span class="math">\(a\)</span> is in
the units of the residual vector norm whereas <span class="math">\(s\)</span> is a squared
norm. For applications it is more convenient to specify <span class="math">\(a\)</span> than
its square.</p>
</dd></dl>

<div class="section" id="instances">
<h3>Instances<a class="headerlink" href="#instances" title="Permalink to this headline">¶</a></h3>
<p>Ceres includes a number of other loss functions. For simplicity we
described their unscaled versions. The figure below illustrates their
shape graphically. More details can be found in
<tt class="docutils literal"><span class="pre">include/ceres/loss_function.h</span></tt>.</p>
<div class="figure align-center" style="width: 500px">
<img alt="_images/loss.png" src="_images/loss.png" style="height: 400px;" />
<p class="caption">Shape of the various common loss functions.</p>
</div>
<dl class="class">
<dt id="TrivialLoss">
<em class="property">class </em><tt class="descname">TrivialLoss</tt><a class="headerlink" href="#TrivialLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = s\]</div>
</dd></dl>

<dl class="class">
<dt id="HuberLoss">
<em class="property">class </em><tt class="descname">HuberLoss</tt><a class="headerlink" href="#HuberLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\begin{split}\rho(s) = \begin{cases} s &amp; s \le 1\\ 2 \sqrt{s} - 1 &amp; s &gt; 1 \end{cases}\end{split}\]</div>
</dd></dl>

<dl class="class">
<dt id="SoftLOneLoss">
<em class="property">class </em><tt class="descname">SoftLOneLoss</tt><a class="headerlink" href="#SoftLOneLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = 2 (\sqrt{1+s} - 1)\]</div>
</dd></dl>

<dl class="class">
<dt id="CauchyLoss">
<em class="property">class </em><tt class="descname">CauchyLoss</tt><a class="headerlink" href="#CauchyLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = \log(1 + s)\]</div>
</dd></dl>

<dl class="class">
<dt id="ArctanLoss">
<em class="property">class </em><tt class="descname">ArctanLoss</tt><a class="headerlink" href="#ArctanLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = \arctan(s)\]</div>
</dd></dl>

<dl class="class">
<dt id="TolerantLoss">
<em class="property">class </em><tt class="descname">TolerantLoss</tt><a class="headerlink" href="#TolerantLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s,a,b) = b \log(1 + e^{(s - a) / b}) - b \log(1 + e^{-a / b})\]</div>
</dd></dl>

<dl class="class">
<dt id="ComposedLoss">
<em class="property">class </em><tt class="descname">ComposedLoss</tt><a class="headerlink" href="#ComposedLoss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="ScaledLoss">
<em class="property">class </em><tt class="descname">ScaledLoss</tt><a class="headerlink" href="#ScaledLoss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="LossFunctionWrapper">
<em class="property">class </em><tt class="descname">LossFunctionWrapper</tt><a class="headerlink" href="#LossFunctionWrapper" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="theory">
<h3>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h3>
<p>Let us consider a problem with a single problem and a single parameter
block.</p>
<div class="math">
\[\min_x \frac{1}{2}\rho(f^2(x))\]</div>
<p>Then, the robustified gradient and the Gauss-Newton Hessian are</p>
<div class="math">
\[\begin{split}g(x) &amp;= \rho'J^\top(x)f(x)\\
H(x) &amp;= J^\top(x)\left(\rho' + 2 \rho''f(x)f^\top(x)\right)J(x)\end{split}\]</div>
<p>where the terms involving the second derivatives of <span class="math">\(f(x)\)</span> have
been ignored. Note that <span class="math">\(H(x)\)</span> is indefinite if
<span class="math">\(\rho''f(x)^\top f(x) + \frac{1}{2}\rho' &lt; 0\)</span>. If this is not
the case, then its possible to re-weight the residual and the Jacobian
matrix such that the corresponding linear least squares problem for
the robustified Gauss-Newton step.</p>
<p>Let <span class="math">\(\alpha\)</span> be a root of</p>
<div class="math">
\[\frac{1}{2}\alpha^2 - \alpha - \frac{\rho''}{\rho'}\|f(x)\|^2 = 0.\]</div>
<p>Then, define the rescaled residual and Jacobian as</p>
<div class="math">
\[\begin{split}\tilde{f}(x) &amp;= \frac{\sqrt{\rho'}}{1 - \alpha} f(x)\\
\tilde{J}(x) &amp;= \sqrt{\rho'}\left(1 - \alpha
                \frac{f(x)f^\top(x)}{\left\|f(x)\right\|^2} \right)J(x)\end{split}\]</div>
<p>In the case <span class="math">\(2 \rho''\left\|f(x)\right\|^2 + \rho' \lesssim 0\)</span>,
we limit <span class="math">\(\alpha \le 1- \epsilon\)</span> for some small
<span class="math">\(\epsilon\)</span>. For more details see <a class="reference internal" href="bibliography.html#triggs">[Triggs]</a>.</p>
<p>With this simple rescaling, one can use any Jacobian based non-linear
least squares algorithm to robustifed non-linear least squares
problems.</p>
</div>
</div>
<div class="section" id="localparameterization">
<h2><a class="reference internal" href="#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a><a class="headerlink" href="#localparameterization" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LocalParameterization">
<em class="property">class </em><tt class="descname">LocalParameterization</tt><a class="headerlink" href="#LocalParameterization" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LocalParameterization</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">LocalParameterization</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Plus</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span>
                    <span class="kt">double</span><span class="o">*</span> <span class="n">x_plus_delta</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">ComputeJacobian</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">jacobian</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">GlobalSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">LocalSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Sometimes the parameters <span class="math">\(x\)</span> can overparameterize a
problem. In that case it is desirable to choose a parameterization
to remove the null directions of the cost. More generally, if
<span class="math">\(x\)</span> lies on a manifold of a smaller dimension than the
ambient space that it is embedded in, then it is numerically and
computationally more effective to optimize it using a
parameterization that lives in the tangent space of that manifold
at each point.</p>
<p>For example, a sphere in three dimensions is a two dimensional
manifold, embedded in a three dimensional space. At each point on
the sphere, the plane tangent to it defines a two dimensional
tangent space. For a cost function defined on this sphere, given a
point <span class="math">\(x\)</span>, moving in the direction normal to the sphere at
that point is not useful. Thus a better way to parameterize a point
on a sphere is to optimize over two dimensional vector
<span class="math">\(\Delta x\)</span> in the tangent space at the point on the sphere
point and then &#8220;move&#8221; to the point <span class="math">\(x + \Delta x\)</span>, where the
move operation involves projecting back onto the sphere. Doing so
removes a redundant dimension from the optimization, making it
numerically more robust and efficient.</p>
<p>More generally we can define a function</p>
<div class="math">
\[x' = \boxplus(x, \Delta x),\]</div>
<p>where <span class="math">\(x\)</span> has the same size as <span class="math">\(x\)</span>, and <span class="math">\(\Delta
x\)</span> is of size less than or equal to <span class="math">\(x\)</span>. The function
<span class="math">\(\boxplus\)</span>, generalizes the definition of vector
addition. Thus it satisfies the identity</p>
<div class="math">
\[\boxplus(x, 0) = x,\quad \forall x.\]</div>
<p>Instances of <a class="reference internal" href="#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a> implement the
<span class="math">\(\boxplus\)</span> operation and its derivative with respect to
<span class="math">\(\Delta x\)</span> at <span class="math">\(\Delta x = 0\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="LocalParameterization::GlobalSize">
int <tt class="descclassname">LocalParameterization::</tt><tt class="descname">GlobalSize</tt><big>(</big><big>)</big><a class="headerlink" href="#LocalParameterization::GlobalSize" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of the ambient space in which the parameter block
<span class="math">\(x\)</span> lives.</p>
</dd></dl>

<dl class="function">
<dt id="LocalParamterization::LocaLocalSize">
int <tt class="descclassname">LocalParamterization::</tt><tt class="descname">LocaLocalSize</tt><big>(</big><big>)</big><a class="headerlink" href="#LocalParamterization::LocaLocalSize" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the tangent space
that <span class="math">\(\Delta x\)</span> lives in.</p>
</dd></dl>

<dl class="function">
<dt id="LocalParameterization::Plus__doubleCP.doubleCP.doublePC">
bool <tt class="descclassname">LocalParameterization::</tt><tt class="descname">Plus</tt><big>(</big>const double* <em>x</em>, const double* <em>delta</em>, double* <em>x_plus_delta</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#LocalParameterization::Plus__doubleCP.doubleCP.doublePC" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#LocalParameterization::Plus__doubleCP.doubleCP.doublePC" title="LocalParameterization::Plus"><tt class="xref cpp cpp-func docutils literal"><span class="pre">LocalParameterization::Plus()</span></tt></a> implements <span class="math">\(\boxplus(x,\Delta x)\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="LocalParameterization::ComputeJacobian__doubleCP.doublePC">
bool <tt class="descclassname">LocalParameterization::</tt><tt class="descname">ComputeJacobian</tt><big>(</big>const double* <em>x</em>, double* <em>jacobian</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#LocalParameterization::ComputeJacobian__doubleCP.doublePC" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Jacobian matrix</p>
<div class="math">
\[J = \left . \frac{\partial }{\partial \Delta x} \boxplus(x,\Delta x)\right|_{\Delta x = 0}\]</div>
<p>in row major form.</p>
</dd></dl>

<div class="section" id="id2">
<h3>Instances<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="IdentityParameterization">
<em class="property">class </em><tt class="descname">IdentityParameterization</tt><a class="headerlink" href="#IdentityParameterization" title="Permalink to this definition">¶</a></dt>
<dd><p>A trivial version of <span class="math">\(\boxplus\)</span> is when <span class="math">\(\Delta x\)</span> is
of the same size as <span class="math">\(x\)</span> and</p>
<div class="math">
\[\boxplus(x, \Delta x) = x + \Delta x\]</div>
</dd></dl>

<dl class="class">
<dt id="SubsetParameterization">
<em class="property">class </em><tt class="descname">SubsetParameterization</tt><a class="headerlink" href="#SubsetParameterization" title="Permalink to this definition">¶</a></dt>
<dd><p>A more interesting case if <span class="math">\(x\)</span> is a two dimensional vector,
and the user wishes to hold the first coordinate constant. Then,
<span class="math">\(\Delta x\)</span> is a scalar and <span class="math">\(\boxplus\)</span> is defined as</p>
<div class="math">
\[\begin{split}\boxplus(x, \Delta x) = x + \left[ \begin{array}{c} 0 \\ 1
                            \end{array} \right] \Delta x\end{split}\]</div>
<p><a class="reference internal" href="#SubsetParameterization" title="SubsetParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">SubsetParameterization</span></tt></a> generalizes this construction to
hold any part of a parameter block constant.</p>
</dd></dl>

<dl class="class">
<dt id="QuaternionParameterization">
<em class="property">class </em><tt class="descname">QuaternionParameterization</tt><a class="headerlink" href="#QuaternionParameterization" title="Permalink to this definition">¶</a></dt>
<dd><p>Another example that occurs commonly in Structure from Motion
problems is when camera rotations are parameterized using a
quaternion. There, it is useful only to make updates orthogonal to
that 4-vector defining the quaternion. One way to do this is to let
<span class="math">\(\Delta x\)</span> be a 3 dimensional vector and define
<span class="math">\(\boxplus\)</span> to be</p>
<blockquote>
<div><div class="math" id="equation-quaternion">
<span class="eqno">(2)</span>\[\boxplus(x, \Delta x) = \left[ \cos(|\Delta x|), \frac{\sin\left(|\Delta x|\right)}{|\Delta x|} \Delta x \right] * x\]</div>
</div></blockquote>
<p>The multiplication between the two 4-vectors on the right hand side
is the standard quaternion
product. <a class="reference internal" href="#QuaternionParameterization" title="QuaternionParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">QuaternionParameterization</span></tt></a> is an implementation
of <a href="#equation-quaternion">(2)</a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="problem">
<h2><a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a><a class="headerlink" href="#problem" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Problem">
<em class="property">class </em><tt class="descname">Problem</tt><a class="headerlink" href="#Problem" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a> holds the robustified non-linear least squares
problem <a href="#equation-ceresproblem">(?)</a>. To create a least squares problem, use
the <a class="reference internal" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Problem::AddResidualBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></tt></a> and
<a class="reference internal" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Problem::AddParameterBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></tt></a> methods.</p>
<p>For example a problem containing 3 parameter blocks of sizes 3, 4
and 5 respectively and two residual blocks of size 2 and 6:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">double</span> <span class="n">x1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">};</span>
<span class="kt">double</span> <span class="n">x2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span> <span class="p">};</span>
<span class="kt">double</span> <span class="n">x3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">7.0</span> <span class="p">};</span>

<span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyUnaryCostFunction</span><span class="p">(...),</span> <span class="n">x1</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyBinaryCostFunction</span><span class="p">(...),</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Problem::AddResidualBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></tt></a> as the name implies, adds a
residual block to the problem. It adds a <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> , an
optional <a class="reference internal" href="#LossFunction" title="LossFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></tt></a> and connects the
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> to a set of parameter block.</p>
<p>The cost function carries with it information about the sizes of
the parameter blocks it expects. The function checks that these
match the sizes of the parameter blocks listed in
<tt class="docutils literal"><span class="pre">parameter_blocks</span></tt>. The program aborts if a mismatch is
detected. <tt class="docutils literal"><span class="pre">loss_function</span></tt> can be <tt class="docutils literal"><span class="pre">NULL</span></tt>, in which case the cost
of the term is just the squared norm of the residuals.</p>
<p>The user has the option of explicitly adding the parameter blocks
using <a class="reference internal" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Problem::AddParameterBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></tt></a>. This causes additional correctness
checking; however, <a class="reference internal" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Problem::AddResidualBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></tt></a> implicitly adds the
parameter blocks if they are not present, so calling
<a class="reference internal" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Problem::AddParameterBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></tt></a> explicitly is not required.</p>
<p><a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a> by default takes ownership of the <tt class="docutils literal"><span class="pre">cost_function</span></tt> and
<tt class="docutils literal"><span class="pre">loss_function</span></tt> pointers. These objects remain live for the life of
the <a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a> object. If the user wishes to keep control over the
destruction of these objects, then they can do this by setting the
corresponding enums in the <tt class="docutils literal"><span class="pre">Problem::Options</span></tt> struct.</p>
<p>Note that even though the Problem takes ownership of <tt class="docutils literal"><span class="pre">cost_function</span></tt>
and <tt class="docutils literal"><span class="pre">loss_function</span></tt>, it does not preclude the user from re-using
them in another residual block. The destructor takes care to call
delete on each <tt class="docutils literal"><span class="pre">cost_function</span></tt> or <tt class="docutils literal"><span class="pre">loss_function</span></tt> pointer only
once, regardless of how many residual blocks refer to them.</p>
<p><a class="reference internal" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Problem::AddParameterBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></tt></a> explicitly adds a parameter
block to the <a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a>. Optionally it allows the user to
associate a <a class="reference internal" href="#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a> object with the parameter
block too. Repeated calls with the same arguments are
ignored. Repeated calls with the same double pointer but a
different size results in undefined behaviour.</p>
<p>You can set any parameter block to be constant using
<a class="reference internal" href="#Problem::SetParameterBlockConstant__doubleP" title="Problem::SetParameterBlockConstant"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::SetParameterBlockConstant()</span></tt></a> and undo this using
<a class="reference internal" href="#Problem::SetParameterBlockVariable__doubleP" title="Problem::SetParameterBlockVariable"><tt class="xref cpp cpp-func docutils literal"><span class="pre">SetParameterBlockVariable()</span></tt></a>.</p>
<p>In fact you can set any number of parameter blocks to be constant,
and Ceres is smart enough to figure out what part of the problem
you have constructed depends on the parameter blocks that are free
to change and only spends time solving it. So for example if you
constructed a problem with a million parameter blocks and 2 million
residual blocks, but then set all but one parameter blocks to be
constant and say only 10 residual blocks depend on this one
non-constant parameter block. Then the computational effort Ceres
spends in solving this problem will be the same if you had defined
a problem with one parameter block and 10 residual blocks.</p>
<p><strong>Ownership</strong></p>
<p><a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a> by default takes ownership of the
<tt class="docutils literal"><span class="pre">cost_function</span></tt>, <tt class="docutils literal"><span class="pre">loss_function</span></tt> and <tt class="docutils literal"><span class="pre">local_parameterization</span></tt>
pointers. These objects remain live for the life of the
<a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a>. If the user wishes to keep control over the
destruction of these objects, then they can do this by setting the
corresponding enums in the <tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem::Options</span></tt> struct.</p>
<p>Even though <a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a> takes ownership of these pointers, it
does not preclude the user from re-using them in another residual
or parameter block. The destructor takes care to call delete on
each pointer only once.</p>
</dd></dl>

<dl class="function">
<dt id="Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C">
ResidualBlockId <tt class="descclassname">Problem::</tt><tt class="descname">AddResidualBlock</tt><big>(</big>CostFunction* <em>cost_function</em>, LossFunction* <em>loss_function</em>, const vector&lt;double*&gt; <em>parameter_blocks</em><big>)</big><a class="headerlink" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Problem::AddParameterBlock__doubleP.i.LocalParameterizationP">
void <tt class="descclassname">Problem::</tt><tt class="descname">AddParameterBlock</tt><big>(</big>double* <em>values</em>, int <em>size</em>, LocalParameterization* <em>local_parameterization</em><big>)</big><a class="headerlink" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Permalink to this definition">¶</a></dt>
<dt id="Problem::AddParameterBlock__doubleP.i">
void <tt class="descclassname">Problem::</tt><tt class="descname">AddParameterBlock</tt><big>(</big>double* <em>values</em>, int <em>size</em><big>)</big><a class="headerlink" href="#Problem::AddParameterBlock__doubleP.i" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Problem::SetParameterBlockConstant__doubleP">
void <tt class="descclassname">Problem::</tt><tt class="descname">SetParameterBlockConstant</tt><big>(</big>double* <em>values</em><big>)</big><a class="headerlink" href="#Problem::SetParameterBlockConstant__doubleP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Problem::SetParameterBlockVariable__doubleP">
void <tt class="descclassname">Problem::</tt><tt class="descname">SetParameterBlockVariable</tt><big>(</big>double* <em>values</em><big>)</big><a class="headerlink" href="#Problem::SetParameterBlockVariable__doubleP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Problem::SetParameterization__doubleP.LocalParameterizationP">
void <tt class="descclassname">Problem::</tt><tt class="descname">SetParameterization</tt><big>(</big>double* <em>values</em>, LocalParameterization* <em>local_parameterization</em><big>)</big><a class="headerlink" href="#Problem::SetParameterization__doubleP.LocalParameterizationP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Problem::NumParameterBlocksC">
int <tt class="descclassname">Problem::</tt><tt class="descname">NumParameterBlocks</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Problem::NumParameterBlocksC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Problem::NumParametersC">
int <tt class="descclassname">Problem::</tt><tt class="descname">NumParameters</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Problem::NumParametersC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Problem::NumResidualBlocksC">
int <tt class="descclassname">Problem::</tt><tt class="descname">NumResidualBlocks</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Problem::NumResidualBlocksC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Problem::NumResidualsC">
int <tt class="descclassname">Problem::</tt><tt class="descname">NumResiduals</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Problem::NumResidualsC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="rotation-h">
<h2><tt class="docutils literal"><span class="pre">rotation.h</span></tt><a class="headerlink" href="#rotation-h" title="Permalink to this headline">¶</a></h2>
<p>Many applications of Ceres Solver involve optimization problems where
some of the variables correspond to rotations. To ease the pain of
work with the various representations of rotations (angle-axis,
quaternion and matrix) we provide a handy set of templated
functions. These functions are templated so that the user can use them
within Ceres Solver&#8217;s automatic differentiation framework.</p>
<dl class="function">
<dt id="AngleAxisToQuaternion:T:__TCP.TP">
void <tt class="descname">AngleAxisToQuaternion&lt;T&gt;</tt><big>(</big>T const* <em>angle_axis</em>, T* <em>quaternion</em><big>)</big><a class="headerlink" href="#AngleAxisToQuaternion:T:__TCP.TP" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a value in combined axis-angle representation to a
quaternion.</p>
<p>The value <tt class="docutils literal"><span class="pre">angle_axis</span></tt> is a triple whose norm is an angle in radians,
and whose direction is aligned with the axis of rotation, and
<tt class="docutils literal"><span class="pre">quaternion</span></tt> is a 4-tuple that will contain the resulting quaternion.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionToAngleAxis:T:__TCP.TP">
void <tt class="descname">QuaternionToAngleAxis&lt;T&gt;</tt><big>(</big>T const* <em>quaternion</em>, T* <em>angle_axis</em><big>)</big><a class="headerlink" href="#QuaternionToAngleAxis:T:__TCP.TP" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a quaternion to the equivalent combined axis-angle
representation.</p>
<p>The value <tt class="docutils literal"><span class="pre">quaternion</span></tt> must be a unit quaternion - it is not
normalized first, and <tt class="docutils literal"><span class="pre">angle_axis</span></tt> will be filled with a value
whose norm is the angle of rotation in radians, and whose direction
is the axis of rotation.</p>
</dd></dl>

<dl class="function">
<dt id="RotationMatrixToAngleAxis:T:__TCP.TP">
void <tt class="descname">RotationMatrixToAngleAxis&lt;T&gt;</tt><big>(</big>T const* <em>R</em>, T* <em>angle_axis</em><big>)</big><a class="headerlink" href="#RotationMatrixToAngleAxis:T:__TCP.TP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="AngleAxisToRotationMatrix:T:__TCP.TP">
void <tt class="descname">AngleAxisToRotationMatrix&lt;T&gt;</tt><big>(</big>T const* <em>angle_axis</em>, T* <em>R</em><big>)</big><a class="headerlink" href="#AngleAxisToRotationMatrix:T:__TCP.TP" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversions between 3x3 rotation matrix (in column major order) and
axis-angle rotation representations.</p>
</dd></dl>

<dl class="function">
<dt id="EulerAnglesToRotationMatrix:T:__TCP.i.TP">
void <tt class="descname">EulerAnglesToRotationMatrix&lt;T&gt;</tt><big>(</big>const T* <em>euler</em>, int <em>row_stride</em>, T* <em>R</em><big>)</big><a class="headerlink" href="#EulerAnglesToRotationMatrix:T:__TCP.i.TP" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversions between 3x3 rotation matrix (in row major order) and
Euler angle (in degrees) rotation representations.</p>
<p>The {pitch,roll,yaw} Euler angles are rotations around the {x,y,z}
axes, respectively.  They are applied in that same order, so the
total rotation R is Rz * Ry * Rx.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionToScaledRotation:T:__TCA.TA">
void <tt class="descname">QuaternionToScaledRotation&lt;T&gt;</tt><big>(</big>const T <em>q</em>[4], T <em>R</em>[3 * 3]<big>)</big><a class="headerlink" href="#QuaternionToScaledRotation:T:__TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a 4-vector to a 3x3 scaled rotation matrix.</p>
<p>The choice of rotation is such that the quaternion
<span class="math">\(\begin{bmatrix} 1 &amp;0 &amp;0 &amp;0\end{bmatrix}\)</span> goes to an identity
matrix and for small <span class="math">\(a, b, c\)</span> the quaternion
<span class="math">\(\begin{bmatrix}1 &amp;a &amp;b &amp;c\end{bmatrix}\)</span> goes to the matrix</p>
<div class="math">
\[\begin{split}I + 2 \begin{bmatrix} 0 &amp; -c &amp; b \\ c &amp; 0 &amp; -a\\ -b &amp; a &amp; 0
      \end{bmatrix} + O(q^2)\end{split}\]</div>
<p>which corresponds to a Rodrigues approximation, the last matrix
being the cross-product matrix of <span class="math">\(\begin{bmatrix} a&amp; b&amp;
c\end{bmatrix}\)</span>. Together with the property that <span class="math">\(R(q1 * q2)
= R(q1) * R(q2)\)</span> this uniquely defines the mapping from <span class="math">\(q\)</span> to
<span class="math">\(R\)</span>.</p>
<p>The rotation matrix <tt class="docutils literal"><span class="pre">R</span></tt> is row-major.</p>
<p>No normalization of the quaternion is performed, i.e.
<span class="math">\(R = \|q\|^2  Q\)</span>, where <span class="math">\(Q\)</span> is an orthonormal matrix
such that <span class="math">\(\det(Q) = 1\)</span> and <span class="math">\(Q*Q' = I\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionToRotation:T:__TCA.TA">
void <tt class="descname">QuaternionToRotation&lt;T&gt;</tt><big>(</big>const T <em>q</em>[4], T <em>R</em>[3 * 3]<big>)</big><a class="headerlink" href="#QuaternionToRotation:T:__TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above except that the rotation matrix is normalized by the
Frobenius norm, so that <span class="math">\(R R' = I\)</span> (and <span class="math">\(\det(R) = 1\)</span>).</p>
</dd></dl>

<dl class="function">
<dt id="UnitQuaternionRotatePoint:T:__TCA.TCA.TA">
void <tt class="descname">UnitQuaternionRotatePoint&lt;T&gt;</tt><big>(</big>const T <em>q</em>[4], const T <em>pt</em>[3], T <em>result</em>[3]<big>)</big><a class="headerlink" href="#UnitQuaternionRotatePoint:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates a point pt by a quaternion q:</p>
<div class="math">
\[\text{result} = R(q)  \text{pt}\]</div>
<p>Assumes the quaternion is unit norm. If you pass in a quaternion
with <span class="math">\(|q|^2 = 2\)</span> then you WILL NOT get back 2 times the
result you get for a unit quaternion.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionRotatePoint:T:__TCA.TCA.TA">
void <tt class="descname">QuaternionRotatePoint&lt;T&gt;</tt><big>(</big>const T <em>q</em>[4], const T <em>pt</em>[3], T <em>result</em>[3]<big>)</big><a class="headerlink" href="#QuaternionRotatePoint:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><p>With this function you do not need to assume that q has unit norm.
It does assume that the norm is non-zero.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionProduct:T:__TCA.TCA.TA">
void <tt class="descname">QuaternionProduct&lt;T&gt;</tt><big>(</big>const T <em>z</em>[4], const T <em>w</em>[4], T <em>zw</em>[4]<big>)</big><a class="headerlink" href="#QuaternionProduct:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[zw = z * w\]</div>
<p>where <span class="math">\(*\)</span> is the Quaternion product between 4-vectors.</p>
</dd></dl>

<dl class="function">
<dt id="CrossProduct:T:__TCA.TCA.TA">
void <tt class="descname">CrossProduct&lt;T&gt;</tt><big>(</big>const T <em>x</em>[3], const T <em>y</em>[3], T <em>x_cross_y</em>[3]<big>)</big><a class="headerlink" href="#CrossProduct:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\text{x_cross_y} = x \times y\]</div>
</dd></dl>

<dl class="function">
<dt id="AngleAxisRotatePoint:T:__TCA.TCA.TA">
void <tt class="descname">AngleAxisRotatePoint&lt;T&gt;</tt><big>(</big>const T <em>angle_axis</em>[3], const T <em>pt</em>[3], T <em>result</em>[3]<big>)</big><a class="headerlink" href="#AngleAxisRotatePoint:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[y = R(\text{angle_axis}) x\]</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Ceres Solver</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html">Building</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Modeling API</a></li>
<li class="toctree-l1"><a class="reference internal" href="solving.html">Solver API</a></li>
<li class="toctree-l1"><a class="reference internal" href="reading.html">Further Reading</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">Acknowledgements</a></li>
<li class="toctree-l1"><a class="reference internal" href="version_history.html">Version History</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial.html"
                        title="previous chapter">Tutorial</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="solving.html"
                        title="next chapter">Solver API</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="solving.html" title="Solver API"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial.html" title="Tutorial"
             >previous</a> |</li>
        <li><a href="index.html">Ceres Solver</a> &raquo;</li> 
      </ul>
    </div>
<div class="footer">
    &copy; Copyright 2013, Google Inc..
</div>





  </body>
</html>