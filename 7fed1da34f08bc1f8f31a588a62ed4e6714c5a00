{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f06a83ba_4b57d09a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-02-27T15:04:35Z",
      "side": 1,
      "message": "here is a first cut of the release notes for 2.1. I hope to cut the first release candidate by end of next week.",
      "revId": "7fed1da34f08bc1f8f31a588a62ed4e6714c5a00",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c3a7c9bb_fa7a2243",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-01T11:36:08Z",
      "side": 1,
      "message": "2.1 looking good. Great work!",
      "revId": "7fed1da34f08bc1f8f31a588a62ed4e6714c5a00",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52e81e89_700190a1",
        "filename": "docs/source/version_history.rst",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-01T11:36:08Z",
      "side": 1,
      "message": "Maybe this full list of changes to `Jet` is also helpful (Markdown-like):\n\n```\n* Jet gained support for\n  * `copysign`\n  * `fma` (fused multiply-add)\n  * `midpoint` (C++20 and above)\n  * `lerp` (C++20 and above)\n  * 3-argument `hypot` (C++17 and above)\n  * `log10`\n  * `log1p`\n  * `exp1m`\n  * `norm` (squared L^2 norm)\n* Quiet floating-point comparison:\n  * `isless`\n  * `isgreater`\n  * `islessgreater`\n  * `islessequal`\n  * `isgreaterequal`\n  * `isunordered`\n  * `signbit`\n  * `fdim`\n* Categorization and comparison operations are applied exclusively and consistently to the scalar part of a Jet now:\n  * `isnan`, `isinf`, `isnormal`, `isfinite`, `fpclassify` (new)\n  * `fmin`, `fmax`\n  * It is now possible to safely compare a Jet against a scalar (or literal) without constructing a Jet first (even if it\u0027s nested):\n\n    \u003ccode\u003e\n       Jet\u003cJet\u003cJet\u003cT, N\u003e, M\u003e, O\u003e x;\n       if (x \u003d\u003d 2) { } // equivalent to x.a.a.a \u003d\u003d 2\n    \u003c/code\u003e\n\n     This enables interaction with various arithmetic functions that expect a scalar like instance, such as `boost::math::pow\u003c-N\u003e` for reciprocal computation.\n```\n\nParticularly, changes to categorization functions `isnan`, `isfinite`, etc., are not backward compatible. Previously, the logic was applied to the infinitesimals as well, although inconsistently (all vs. any).",
      "revId": "7fed1da34f08bc1f8f31a588a62ed4e6714c5a00",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db0eb566_83683c99",
        "filename": "docs/source/version_history.rst",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-01T17:13:31Z",
      "side": 1,
      "message": "I think this raises an interesting question. For debugging purposes we may want to have specialized functions which do check that the entire jet is zero or finite. \n\nOr maybe add something to Jets which will do this checking when compiled in debug mode?",
      "parentUuid": "52e81e89_700190a1",
      "revId": "7fed1da34f08bc1f8f31a588a62ed4e6714c5a00",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0aa97c4c_85f22b43",
        "filename": "docs/source/version_history.rst",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-01T17:30:52Z",
      "side": 1,
      "message": "Yes, there\u0027s a comment in `jet.h` that exactly addresses this. The check should be done explicitly on the dual part which allows choosing the conjunction (i.e., all/and vs. any/or).",
      "parentUuid": "db0eb566_83683c99",
      "revId": "7fed1da34f08bc1f8f31a588a62ed4e6714c5a00",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20cf1630_a7091b44",
        "filename": "docs/source/version_history.rst",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-01T17:32:01Z",
      "side": 1,
      "message": "sure but when the user is writing templated code, unless they do some template programming themselves they will not be able to just check on the type T. so we should perhaps add some functions which address this usecase?",
      "parentUuid": "0aa97c4c_85f22b43",
      "revId": "7fed1da34f08bc1f8f31a588a62ed4e6714c5a00",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ca3a10a_aa764d8d",
        "filename": "docs/source/version_history.rst",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-01T17:44:58Z",
      "side": 1,
      "message": "I already mentioned this during the review (and I believe you did not disagree): there\u0027s just no real use for that. The problem is that you would need to choose a convention for aggregating categorization results (all vs. any, if `std::is*` overloads were to be used) which may be suitable in one situation but not the other. For the rare case where sanity checks are needed, the easiest and unambiguous way to do this is by letting the user write his own helper functions.",
      "parentUuid": "20cf1630_a7091b44",
      "revId": "7fed1da34f08bc1f8f31a588a62ed4e6714c5a00",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c8d168f_25708852",
        "filename": "docs/source/version_history.rst",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-03-01T17:47:54Z",
      "side": 1,
      "message": "oh I am not talking about modifying the semantics of existing functions. I am good with that, they should be consistent with comparison semantics. \n\nI am thinking about adding a new very verbosely named function sort of like the DCHECK macros in glog.",
      "parentUuid": "5ca3a10a_aa764d8d",
      "revId": "7fed1da34f08bc1f8f31a588a62ed4e6714c5a00",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f3d1e24_1be9cc8c",
        "filename": "docs/source/version_history.rst",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-03-01T17:58:26Z",
      "side": 1,
      "message": "Ah, I understand now. I think it would be doable to just add overloads that can be called on `T` as follows:\n```\nvoid foo(T value)\n{\n   DCHECK(ceres::isfinite(value, ceres::All));\n   DCHECK(ceres::isfinite(value, ceres::Any));\n}\n```\nHowever, there\u0027s all the case where the check should be applied to gradients only, without considering the scalar part.\n\nA clean API will require spending some effort.",
      "parentUuid": "1c8d168f_25708852",
      "revId": "7fed1da34f08bc1f8f31a588a62ed4e6714c5a00",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}