{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9d8b10b0_cb276918",
        "filename": "include/ceres/rotation.h",
        "patchSetId": 1
      },
      "lineNbr": 749,
      "author": {
        "id": 6612
      },
      "writtenOn": "2023-01-14T09:40:37Z",
      "side": 0,
      "message": "I incorrectly assumed that the scalar part is in the first coefficient not in the last one. Due to split terms, the denominator in the 2-argument `hypot` can therefore become zero. Since we deal with a unit quaternion, a more straightforward solution would be to exchange the nesting of expressions as follows:\n```\nhypot(hypot(q[0], q[1], q[2]), q[3])\n```\nUnless the scalar part is zero this should ensure an equivalent result.",
      "revId": "f1113c08abec23462182a5a8235f8ab47277ec4d",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42f3b354_f815adbf",
        "filename": "include/ceres/rotation.h",
        "patchSetId": 1
      },
      "lineNbr": 749,
      "author": {
        "id": 6612
      },
      "writtenOn": "2023-01-14T12:29:07Z",
      "side": 0,
      "message": "\u003e I incorrectly assumed that the scalar part is in the first coefficient not in the last one.\n\nI meant the outer way around.",
      "parentUuid": "9d8b10b0_cb276918",
      "revId": "f1113c08abec23462182a5a8235f8ab47277ec4d",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69a257b3_b456a8ac",
        "filename": "include/ceres/rotation.h",
        "patchSetId": 1
      },
      "lineNbr": 749,
      "author": {
        "id": 6732
      },
      "writtenOn": "2023-01-14T12:42:45Z",
      "side": 0,
      "message": "I hope you don\u0027t mind if I make a comment.\n\nDoes it worthy to use hypot here (and in the same places)?\n\nI mean that additinal operations with `Jet`s introduce additional calculations with their `.v` components. Especially here when we initially calculate `sqrt(x^2 + y^2 + z^2)` when raise it to power 2 and again take a squre root. Personally I often use `stride\u003d32` for big tasks where there is almost impossible estimate jacobians numerically and it is hard to predict how much slower the code will become because of `hypot`. I know that `hypot` is safe for large values but here we are dealing with quaternion `x,y,z,w` and they are not expected to be very big (or am I wrong?).\n\nIf `x,y,z,w` are small usage of hypot again does not save us from division by small number\n\nSo `hypot` slows down the code both for `Jet`s and `double` (`hypot` much slower than `sqrt(...)`). As seems to me it should be used only in places where we may expect so large `double`s so that their power of 2 does not fit into `double` range",
      "parentUuid": "9d8b10b0_cb276918",
      "revId": "f1113c08abec23462182a5a8235f8ab47277ec4d",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7ab03a95_3219c2ce",
        "filename": "include/ceres/rotation.h",
        "patchSetId": 1
      },
      "lineNbr": 749,
      "author": {
        "id": 6612
      },
      "writtenOn": "2023-01-14T13:32:47Z",
      "side": 0,
      "message": "Are you claiming that the scaling performed by `hypot` considerably slows down computations? Can you provide a benchmark that confirms this claim?\n\n`hypot` is not only useful for avoiding over/underflows but also behaves numerically better in general than naive computation which here is important particularly for quaternions close to identity.\n\nConsider the following example (https://godbolt.org/z/494rcz4dq):\n\n```\n#include \u003ccmath\u003e\n#include \u003ciostream\u003e\n#include \u003ccassert\u003e\n\ndouble naive_norm(double a, double b)\n{\n    return std::sqrt(a * a + b * b);\n}\n\nint main()\n{\n    constexpr double a \u003d 5e-8;\n    constexpr double b \u003d 0.9999;\n\n    double c1 \u003d naive_norm(a, b);\n    double c2 \u003d std::hypot(a, b);\n    \n    std::cout \u003c\u003c std::abs(c1 - c2) \u003c\u003c std::endl;\n\n    assert(c1 \u003d\u003d c2);\n}\n```\n\nwhich does not produce the same results with a difference of 1.11022e-16 on my x86_64 machine. We could, of course, discuss whether such differences are significant.",
      "parentUuid": "69a257b3_b456a8ac",
      "revId": "f1113c08abec23462182a5a8235f8ab47277ec4d",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "893cf3ea_52828bb6",
        "filename": "include/ceres/rotation.h",
        "patchSetId": 1
      },
      "lineNbr": 749,
      "author": {
        "id": 6732
      },
      "writtenOn": "2023-01-15T15:27:54Z",
      "side": 0,
      "message": "Actually my point was not about numerical differences (I am sure they are present). I am talking about silently changing performance for `Jet`s.  Below I\u0027ve written small benchmark which\n* compares `std::hypot(x, y)` and `std::hypot(x, y, z)` with corresponding `std::sqrt`-based computations for scalar types. Spoiler: `std::hypot` may be significantly slower than `std::sqrt`.\n* compares 3 ways of calculating `hypot(x, y, z, w)` where `x`, `y`, `z`, `w` are `Jet`s. Spoiler: fastest way is to write norm calculation as \n```\nT norm \u003d sqrt(x*x + y*y + z*z + w*w);\n```\n\n\nI didn\u0027t found a way to attach files so just provided links to my google disk:\n* Benchmark source code file here https://drive.google.com/file/d/1utwoHHTGwzbq1xuCN_emq8b0Bgqg27Zy/view?usp\u003dshare_link. Put it into `ceres/internal` dir and add to `internal/ceres/CMakeLists.txt`.\n* Results on my local machine for `double`s generated in range `(-1000, 1000)`: https://drive.google.com/file/d/1xpZiI2_l6IX6-jyM6LUBZHheJOeRhVyC/view?usp\u003dsharing\n* Results on my local machine for `double`s generated in range `(-10000000000, 10000000000)`: https://drive.google.com/file/d/1vwo_UJYIYghtVY6l4Kvs-D8pmvWcwEmM/view?usp\u003dsharing\n\nObservations:\n*  Actually performance of `std::hypot(x, y)` degrades significantly under `double`s as compared with `std::sqrt(x*x + y*y)`. especially to compare `std::hypot` vs `std::sqrt`. But nevertheless I agree that safety may be more important here\n* As for `Jet`s if both variants\n```\nT norm \u003d hypot(w, hypot(x, hypot(y, z)));\n```\nand \n```\nT norm \u003d hypot(w, hypot(x, y, z));\n```\n(where `hypot`s are trivially implemented using `sqrt` for `Jet`s) are slower than\n```\nT norm \u003d sqrt(x*x + y*y + z*z + w*w);\n```\nbecause every time we take square root and raise to power 2 we perform additional (absolutely redundant) computations over `.v` components (derivatives). \n\nMy final point is that safety is good, and actually for scalar types it is better to use `std::hypot` but we should carefully treat `Jet`s. Acceptable variant is to write something like\n```\nT norm;\nif constexpr (std::is_floating_point_v\u003cT\u003e) {\n  norm \u003d hypot(w, hypot(x, y, z));\n} else {\n  norm \u003d sqrt(w * w + x * x + y * y + z * z);\n}\n```\nIt seems to represent an appropriate balance.\n\n\nP.S. \n* Comparitively slow `std::hypot` performance also reported on stackoverflow https://stackoverflow.com/questions/3764978/why-hypot-function-is-so-slow where iterative implementation is demonstrated\n* It seems that `std::hypot(x, y, z)` home some special implementation because it is faster than `std::hypot(x, y)` for random numbers (it looked very suspicious to me that benchmarked shows that 3 args variant of `std::hypot` is faster).",
      "parentUuid": "7ab03a95_3219c2ce",
      "revId": "f1113c08abec23462182a5a8235f8ab47277ec4d",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}