{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9d8b10b0_cb276918",
        "filename": "include/ceres/rotation.h",
        "patchSetId": 1
      },
      "lineNbr": 749,
      "author": {
        "id": 6612
      },
      "writtenOn": "2023-01-14T09:40:37Z",
      "side": 0,
      "message": "I incorrectly assumed that the scalar part is in the first coefficient not in the last one. Due to split terms, the denominator in the 2-argument `hypot` can therefore become zero. Since we deal with a unit quaternion, a more straightforward solution would be to exchange the nesting of expressions as follows:\n```\nhypot(hypot(q[0], q[1], q[2]), q[3])\n```\nUnless the scalar part is zero this should ensure an equivalent result.",
      "revId": "f1113c08abec23462182a5a8235f8ab47277ec4d",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42f3b354_f815adbf",
        "filename": "include/ceres/rotation.h",
        "patchSetId": 1
      },
      "lineNbr": 749,
      "author": {
        "id": 6612
      },
      "writtenOn": "2023-01-14T12:29:07Z",
      "side": 0,
      "message": "\u003e I incorrectly assumed that the scalar part is in the first coefficient not in the last one.\n\nI meant the outer way around.",
      "parentUuid": "9d8b10b0_cb276918",
      "revId": "f1113c08abec23462182a5a8235f8ab47277ec4d",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69a257b3_b456a8ac",
        "filename": "include/ceres/rotation.h",
        "patchSetId": 1
      },
      "lineNbr": 749,
      "author": {
        "id": 6732
      },
      "writtenOn": "2023-01-14T12:42:45Z",
      "side": 0,
      "message": "I hope you don\u0027t mind if I make a comment.\n\nDoes it worthy to use hypot here (and in the same places)?\n\nI mean that additinal operations with `Jet`s introduce additional calculations with their `.v` components. Especially here when we initially calculate `sqrt(x^2 + y^2 + z^2)` when raise it to power 2 and again take a squre root. Personally I often use `stride\u003d32` for big tasks where there is almost impossible estimate jacobians numerically and it is hard to predict how much slower the code will become because of `hypot`. I know that `hypot` is safe for large values but here we are dealing with quaternion `x,y,z,w` and they are not expected to be very big (or am I wrong?).\n\nIf `x,y,z,w` are small usage of hypot again does not save us from division by small number\n\nSo `hypot` slows down the code both for `Jet`s and `double` (`hypot` much slower than `sqrt(...)`). As seems to me it should be used only in places where we may expect so large `double`s so that their power of 2 does not fit into `double` range",
      "parentUuid": "9d8b10b0_cb276918",
      "revId": "f1113c08abec23462182a5a8235f8ab47277ec4d",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7ab03a95_3219c2ce",
        "filename": "include/ceres/rotation.h",
        "patchSetId": 1
      },
      "lineNbr": 749,
      "author": {
        "id": 6612
      },
      "writtenOn": "2023-01-14T13:32:47Z",
      "side": 0,
      "message": "Are you claiming that the scaling performed by `hypot` considerably slows down computations? Can you provide a benchmark that confirms this claim?\n\n`hypot` is not only useful for avoiding over/underflows but also behaves numerically better in general than naive computation which here is important particularly for quaternions close to identity.\n\nConsider the following example (https://godbolt.org/z/494rcz4dq):\n\n```\n#include \u003ccmath\u003e\n#include \u003ciostream\u003e\n#include \u003ccassert\u003e\n\ndouble naive_norm(double a, double b)\n{\n    return std::sqrt(a * a + b * b);\n}\n\nint main()\n{\n    constexpr double a \u003d 5e-8;\n    constexpr double b \u003d 0.9999;\n\n    double c1 \u003d naive_norm(a, b);\n    double c2 \u003d std::hypot(a, b);\n    \n    std::cout \u003c\u003c std::abs(c1 - c2) \u003c\u003c std::endl;\n\n    assert(c1 \u003d\u003d c2);\n}\n```\n\nwhich does not produce the same results with a difference of 1.11022e-16 on my x86_64 machine. We could, of course, discuss whether such differences are significant.",
      "parentUuid": "69a257b3_b456a8ac",
      "revId": "f1113c08abec23462182a5a8235f8ab47277ec4d",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}