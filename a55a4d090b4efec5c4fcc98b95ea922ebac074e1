{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f5c2ab6e_cfc6eda1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-08-07T19:03:13Z",
      "side": 1,
      "message": "Mark, I like the general shape and size of this change. Thank you for making the change from linear solver to preconditioner.\n\nI would like to review it and land it in a couple of pieces (this is how I have tried to do various other changes like this).\n\n0. There are a bunch of small corrections to comments and documentation get those out of the way and in quickly. so that we can focus on the technical part of this change (e.g. changes in linear_least_squares_problem.cc. implicit_schur_complement.cc etc).\n1. Add the basic PowerSeriesExpansionPreconditioner on its own with tests but it does not have to integrated into the API.\n2. Add the initialization (I am wondering if the initialization may be helpful to iterative schur solvers in general when when not using this preconditioner). \n3. Integrate the preconditioner into the public API and into examples.\n\nI think this will allow me to review carefully, and iterate quickly without creating too much churn.\n",
      "revId": "a55a4d090b4efec5c4fcc98b95ea922ebac074e1",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c9c24bd_9363bf24",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6667
      },
      "writtenOn": "2022-08-08T13:23:27Z",
      "side": 1,
      "message": "Sameer, to make it clear: you expect me to open 4 separate \"pull requests\" matching the list you provided?",
      "parentUuid": "f5c2ab6e_cfc6eda1",
      "revId": "a55a4d090b4efec5c4fcc98b95ea922ebac074e1",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e96b054e_c833f1a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-08-08T13:25:30Z",
      "side": 1,
      "message": "yes that is my suggestion",
      "parentUuid": "9c9c24bd_9363bf24",
      "revId": "a55a4d090b4efec5c4fcc98b95ea922ebac074e1",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca501590_d66960d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6667
      },
      "writtenOn": "2022-08-08T13:34:11Z",
      "side": 1,
      "message": "Reusing for #1.\n\nAsking for commentary about the preferred way to test the PowerSeriesExpansionPreconditioner class and an implementation of ImplicitSchurComplement::RightMultiply_Z.",
      "parentUuid": "e96b054e_c833f1a1",
      "revId": "a55a4d090b4efec5c4fcc98b95ea922ebac074e1",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6db5a9a2_e96426fa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-08-08T13:43:16Z",
      "side": 1,
      "message": "for implicit_schur_complement::rightmultiply_z (I am not fond of the name but we can come back to it) you can just test exact results computed using a different matrix representation. For example you could construct a dense jacobian, partition it into E and F blocks and do the computation that rightmultiply_z is doing and compare the results upto some tolerance.\n\nThis is sort of but not exactly how the implicit schur complement tests are done right now, but they are not great (my fault). I could use some help refactoring them if you are up to it. If not, then just add tests for rightmultiply_z and I will look at refactoring the rest of the tests.\n\nas for the power series expansion preconditioner, there things are a bit more complicated. \n\nI think there are two routes there. \n\nThe first one is where you have matrices where you know that a fixed (small) number of iterations of the preconditioner will give you the exact result. \nyou could also play with diagonal matrices here.\nand then have some tests where you have relatively well conditioned matrices so you are able to run the preconditioner to convergence and compare to the actual inverse computed using Cholesky decomposition.",
      "parentUuid": "ca501590_d66960d7",
      "revId": "a55a4d090b4efec5c4fcc98b95ea922ebac074e1",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4f9dc073_302acf18",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6667
      },
      "writtenOn": "2022-08-10T14:43:05Z",
      "side": 1,
      "message": "Sameer, i am not really understood the goal of refactoring you mentioned, so i simply added the test for ImplicitSchurComplement::InversePowerSeriesOperatorRightMultiply. Will find a time for preconditioner tests tomorrow.",
      "parentUuid": "6db5a9a2_e96426fa",
      "revId": "a55a4d090b4efec5c4fcc98b95ea922ebac074e1",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cd3b458d_950cbdce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-08-10T16:15:30Z",
      "side": 1,
      "message": "mark sorry for not being clear, your refactoring is good. nothing more needs to be done there.",
      "parentUuid": "4f9dc073_302acf18",
      "revId": "a55a4d090b4efec5c4fcc98b95ea922ebac074e1",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}