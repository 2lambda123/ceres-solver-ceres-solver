{
  "comments": [
    {
      "key": {
        "uuid": "f09c7530_0d2705e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 6372
      },
      "writtenOn": "2020-08-03T11:43:34Z",
      "side": 1,
      "message": "Sorry for hijacking this discussion. As a potential user, I really appreciate this functionality and want to add a little comment regarding the API.\n\nIt would be great to have access to the resulting linear sub-system. The reason is: a linear cost function is the standard way to represent the sub-system, but for things like Quaternions it might be better to do this as manifold operation. With access to the resulting sub-system, everyone could choose whether to use the provided linear cost function or to create a custom one.\nMaybe this could be achieved by exposing one of the lower level functions?",
      "revId": "e3aa45bd8d7501036d3a17e10f655600d4617601",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e19735c9_7e4867aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2020-08-04T20:43:11Z",
      "side": 1,
      "message": "Tim, did you have an API in mind?",
      "parentUuid": "f09c7530_0d2705e0",
      "revId": "e3aa45bd8d7501036d3a17e10f655600d4617601",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10f21a72_7af31ba3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 6372
      },
      "writtenOn": "2020-08-05T09:38:29Z",
      "side": 1,
      "message": "I could imagine two different approaches, the fist one requires only minimal changes:\n\n1.a) MarginalizeOutVariables() returns the ResidualBlockId of the new linear cost function.\n1.b) LinearCostFunction() has a getter for its jacobian and linear residual(b).\n\u003d\u003e This would allow the user to get the involved parameter blocks (using the ResidualBlockId) as well as the linear subsystem. It would be possible to remove the LinearCostFunction and replace it with a custom one.\n\nThe second approach would be more involved:\n2.a) MarginalizeOutVariables() doesn\u0027t add the LinearCostFunction to the problem at all. Instead, it returns jacobian, linear residual and the parameter blocks of the markov blanket. Maybe also their sizes for convenience.\n2.b) It is up to the user to add the new LinearCostFunction.\n2.c) The current MarginalizeOutVariables() function becomes MarginalizeOutVariablesAndAddCost().\n\u003d\u003e The user would have the explicit choice whether to use a custom cost function or the provided one.\n\nTo be honest, I\u0027m not sure how many user will use a custom cost function. I would use it in some cases, but the majority might be totally fine with the provided one. So I slightly prefer the first solution -- it has a cleaner interface.\nReturning the ResidualBlockId for the new cost function should done anyway, otherwise it would be impossible to remove it explicitly from the problem.",
      "parentUuid": "e19735c9_7e4867aa",
      "revId": "e3aa45bd8d7501036d3a17e10f655600d4617601",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb745263_969570c5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 6372
      },
      "writtenOn": "2020-08-05T14:37:55Z",
      "side": 1,
      "message": "\u003e Patch Set 4:\n\u003e \n\u003e Tim,\n\u003e \n\u003e Is the presence of the manifold the only reason to do this? if so, shouldn\u0027t the margnialization function account for the presence of the manifold instead of the user having to do this?\n\u003e \n\u003e Sameer\n\nHi Sameer,\n\nit is at least the only reason that I\u0027m aware off.\n\nI think an \"ideal\" marginalization should care about manifolds. But this requires to implement a box-minus operator for each local parameterization in order to construct the correct cost function.\nSince the number of blocks of this function can vary at runtime, autodiff isn\u0027t a good option. So Jacobians are also required for this operator.\n\nIt is possible, but exhaustive to do it for the general case. It would also raise the burden of writing new local parameterizations, because everyone would have to implement an additional minus operator.\nOn the other hand it is relatively easy to do for a specific case, where only one ore two local parametrizations are involved.\n\nAdditionally, marginalization is a linear approximation anyway. So it seems acceptable to do this further approximation for the cost function.\nHowever, an interface to represent it exactly would be nice. :-)\n\nBest Regards\nTim",
      "revId": "e3aa45bd8d7501036d3a17e10f655600d4617601",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6fc5a7ac_be3b049b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 6297
      },
      "writtenOn": "2020-08-05T17:30:38Z",
      "side": 1,
      "message": "I think we are clear on the following point, but I just want to say explicitly that the marginalization prior is on the global coordinates of the Markov blanket, it is integrating out the marginalized variables wrt their local coordinates. Integrating out in overparameterized global coordinates would of course neglect information and is not appropriate for manifolds.\n\nAs I see it, the primary choice in the formulation is whether to compute the prior on the global coordinates or local coordinates of the Markov blanket variables. I have seen both approaches taken, but the former is a bit simpler for the reasons Tim noted. I\u0027m not sure in what cases the latter would be preferred? It may be possible to approximate ominus using the pseudoinverse of the Jacobian of the parameterization, but that may not be ideal.",
      "parentUuid": "fb745263_969570c5",
      "revId": "e3aa45bd8d7501036d3a17e10f655600d4617601",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": false
    }
  ]
}