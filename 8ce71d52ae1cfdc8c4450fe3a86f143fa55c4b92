{
  "comments": [
    {
      "key": {
        "uuid": "af48cda1_c4d3d111",
        "filename": "internal/ceres/coordinate_descent_minimizer.cc",
        "patchSetId": 2
      },
      "lineNbr": 219,
      "author": {
        "id": 5001
      },
      "writtenOn": "2017-11-21T00:36:28Z",
      "side": 1,
      "message": "Indentation here seems off; not sure if this should change or not.",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "859c601b_860e2b1a",
        "filename": "internal/ceres/coordinate_descent_minimizer.cc",
        "patchSetId": 2
      },
      "lineNbr": 219,
      "author": {
        "id": 5435
      },
      "writtenOn": "2017-11-21T01:36:00Z",
      "side": 1,
      "message": "I\u0027m not sure what the best way to format this is.  The body of the for loop is indented wrt to the openmp for loop.  The TBB code path has an additional indentation due to the task_arena context.  The line 219 closes the parallel_for and the line on 220 closes the task_arena.  \n\nMaybe 219 should be indented one more level?",
      "parentUuid": "af48cda1_c4d3d111",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d6d7002e_3cfdb5da",
        "filename": "internal/ceres/coordinate_descent_minimizer.cc",
        "patchSetId": 2
      },
      "lineNbr": 219,
      "author": {
        "id": 5001
      },
      "writtenOn": "2017-11-27T02:17:45Z",
      "side": 1,
      "message": "You\u0027re right; what\u0027s here is fine.",
      "parentUuid": "859c601b_860e2b1a",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5555696c_16b82603",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 5001
      },
      "writtenOn": "2017-11-21T00:36:28Z",
      "side": 1,
      "message": "Does this work reasonably for multiple calls to solve? May be worth commenting on the semantics here, since looking up the tbb semantics is onerous.",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5cf1d9c3_2a9726a8",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 5002
      },
      "writtenOn": "2017-11-27T19:04:32Z",
      "side": 1,
      "message": "Keir, what do you mean by multiple calls here? do you mean multiple sequential calls? or multiple simultaneous calls?\n\nalso do we know if num_threads \u003d 1 leads to a no-op here?",
      "parentUuid": "5555696c_16b82603",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2d729b1_4c0a4347",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 5001
      },
      "writtenOn": "2017-11-27T19:49:12Z",
      "side": 1,
      "message": "I mean multiple top-level calls from the user. E.g.\n\n  for (...) {\n    ceres::Solve(...);\n  }\n\nThis will invoke task_scheduler_init() many times. I just want to make sure this is sane and supported. Furthermore, what happens if the user is using TBB? Does this work with nested TBB?",
      "parentUuid": "5cf1d9c3_2a9726a8",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6cee55b_93a38b54",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 5435
      },
      "writtenOn": "2017-11-28T00:37:58Z",
      "side": 1,
      "message": "You can call task_scheduler_init() as many times as you want.  However, only the first one instantiated will be honored, which means you can\u0027t change the number of active threads.\n\nIf the user is using TBB and called task_scheduler_init, then the call in Ceres does nothing.  If the user requested only 1 thread and Ceres wants 10 threads, then there will only be 1 thread available.\n\nI decided to remove the explicit call to tbb_task_scheduler_init here to simplify the code and logic.  Since we have moved to the task_arena\u0027s they will control the maximum number of threads Ceres is allowed to use.  This allows TBB to determine the correct number of threads to use for the application. This also follows Intel\u0027s recommendation below for performance.\n\n\"To minimize time overhead, it is best to rely upon automatic creation of the task scheduler, or create a single task_scheduler_init object whose activation spans all uses of the library\u0027s task scheduler.\"\n\nRE: \"also do we know if num_threads \u003d 1 leads to a no-op here?\"\n\nI have not been able to find any documentation on what happens if you only want 1 thread.  I looked through the code, but it is hard to know if there is a fast path.  I empirically tested with and without TBB on a program that calls 1500 small problems to solve and they were about the same test time accounting for the variability in timing, load etc.",
      "parentUuid": "a2d729b1_4c0a4347",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9ef13cc_fd71e86d",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 5005
      },
      "writtenOn": "2017-11-28T00:45:27Z",
      "side": 1,
      "message": "I\u0027m not convinced about this, since most users will not be using TBB in their own code (blind assertion without data, based on my experience).\n\nI suggest the following behaviour:\n\n- Keep the current call in-place\n- Add an option to the struct near the threading options that allows disabling calling this init, with appropriate documentation.\n- Detect a requested vs actual thread mismatch. For example, query TBB to see how many threads it is using. Then fail/crash with a useful error in this case (no surprises for the user)!\n\nIt\u0027s important to make this deterministic. For example, if a user had the following:\n\n  ceres::Solve() // w/ num_threads \u003d\u003d 10\n  UsersFunctionThatDoesTBBInit()  // w/ num_threads\u003d2 \u003c-- OOPS!\n\nand \n\n  UsersFunctionThatDoesTBBInit() // w/ num_threads \u003d 2\n  ceres::Solve() // w/ num_threads \u003d 10 \u003c-- OOPS!\n\nBoth cases are bad. By requiring the user to configure Ceres in the uncommon case (to NOT call thread init), I believe the result will be better overall.",
      "parentUuid": "e6cee55b_93a38b54",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0011e016_dd205f51",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 5435
      },
      "writtenOn": "2017-11-28T01:11:38Z",
      "side": 1,
      "message": "I don\u0027t know if this problem has a perfect answer.\n\nIf we do bullet #2 and #3 above, then we are exposing the internal implementation to the user.  This clutters the API and may not do anything if we aren\u0027t using TBB.\n\nIf we do #3, then we have to include another option to disable this because the user might not be able to solve this if an external library uses TBB and calls init.",
      "parentUuid": "c9ef13cc_fd71e86d",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12a2050c_8985eece",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 5005
      },
      "writtenOn": "2017-11-28T01:17:08Z",
      "side": 1,
      "message": "We already expose some internals to the user; I don\u0027t see this as in issue. The default setting will be to call TBB init; only if you care and are using TBB yourself, will you need to disable the call.\n\nFor #3 to be an issue, it\u0027s a relatively contrived case. You\u0027d need to both\n- Be setting the number of threads explicitly\n- But not be calling TBB init\n- While someone else is calling your library with calling TBB init\n\nThe solution is not a big deal, you can just set the threads to whatever TBB reports in in use. Or we could add an option to not fail in that case.",
      "parentUuid": "0011e016_dd205f51",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ec9f6bfe_039bb40d",
        "filename": "internal/ceres/solver.cc",
        "patchSetId": 2
      },
      "lineNbr": 518,
      "author": {
        "id": 5435
      },
      "writtenOn": "2017-11-28T01:42:33Z",
      "side": 1,
      "message": "I don\u0027t think any of this is worth the effort. What do we gain by explicitly calling init?  We will never run with more threads than we desire by using task_arena. The checks only alert the user of the mismatch. One could argue that a user should understand all the implications of using TBB when setting up their program. \n\nI\u0027ll wait to get a consensus before doing anything.",
      "parentUuid": "12a2050c_8985eece",
      "revId": "8ce71d52ae1cfdc8c4450fe3a86f143fa55c4b92",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329",
      "unresolved": true
    }
  ]
}