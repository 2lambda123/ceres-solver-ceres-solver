{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a01a285c_5c3f52aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6141
      },
      "writtenOn": "2022-12-08T19:29:51Z",
      "side": 1,
      "message": "I decided to utilize lazy evaluation of Eigen expressions.\n\nExpression in the form `lhs \u003d rhs;` transforms into a call to `ParallelEvaluate(context, num_threads, lhs, rhs)`\n\nThere is, however one caveat: since lhs is used by non-const reference, not every use-case when lhs is an expression is supported.\n\n\n\nI think that a more beautiful way would be to make a deeper dive into Eigen (by adding a special expression and evaluator classes) in order to have `lhs \u003d ParallelEvaluator(rhs);` syntax, but I haven\u0027t managed to get this working yet.\n\n\nI have added a small benchmark for several vector-operations from ISC:\n\n```\n-------------------------------------------------------------\nBenchmark                   Time             CPU   Iterations\n-------------------------------------------------------------\nSetZero               9832418 ns      9832333 ns           73\nSetZeroParallel/1     6063837 ns      6063462 ns          116\nSetZeroParallel/2     3183456 ns      3126834 ns          224\nSetZeroParallel/4     1645465 ns      1616541 ns          430\nSetZeroParallel/8     1020421 ns       984973 ns          695\nSetZeroParallel/16     770841 ns       739225 ns          926\n\nNegate                5830365 ns      5829621 ns          120\nNegateParallel/1      5886958 ns      5885886 ns          120\nNegateParallel/2      3184665 ns      3158320 ns          227\nNegateParallel/4      1690816 ns      1551063 ns          456\nNegateParallel/8      1040571 ns       960613 ns          736\nNegateParallel/16      808874 ns       727450 ns         1000\n\nAssign               13290358 ns     13290306 ns           49\nAssignParallel/1     10945638 ns     10945530 ns           58\nAssignParallel/2      5538354 ns      5486730 ns          115\nAssignParallel/4      2953912 ns      2923447 ns          251\nAssignParallel/8      2098615 ns      2047684 ns          336\nAssignParallel/16     1935174 ns      1816640 ns          384\n\nD2X                  14918280 ns     14918087 ns           44\nD2XParallel/1        15203023 ns     15199746 ns           43\nD2XParallel/2         7852668 ns      7773736 ns           83\nD2XParallel/4         4166785 ns      3992421 ns          174\nD2XParallel/8         2920911 ns      2860503 ns          244\nD2XParallel/16        2694386 ns      2649985 ns          260\n```\n\nThere is a discrepancy between \"regular\" and \"parallel\" code in single-threaded execution for `SetZero` and `Assign` benchmarks. I was not able to identify the exact reason for this yet.",
      "revId": "1ba21606c470bfa700d2005aecc23414e05d2a68",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "813ad526_7afe1ff7",
        "filename": "internal/ceres/parallel_for.h",
        "patchSetId": 2
      },
      "lineNbr": 97,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-12-08T20:22:42Z",
      "side": 1,
      "message": "why are we introducing more variants here? why do we have these functions which take tuples as input and not just start and end?",
      "range": {
        "startLine": 97,
        "startChar": 20,
        "endLine": 97,
        "endChar": 30
      },
      "revId": "1ba21606c470bfa700d2005aecc23414e05d2a68",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2da16ddd_eafa94b2",
        "filename": "internal/ceres/parallel_for.h",
        "patchSetId": 2
      },
      "lineNbr": 366,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-12-08T20:22:42Z",
      "side": 1,
      "message": "So looking at the callsites at how it is being used, I think ParallelEvaluate is a confusing name. A better name IMO is ParallelAssign, since what you are really doing is assigning the rhs block wise to the rhs. It will make \n\nParallelEvaluate(options_.context, \n                 options_.num_threads, \n                 tmp_e_cols_2_, \n                 -tmp_e_cols_2_);\n\n\nParallelAssign(options_.context, \n               options_.num_threads, \n               tmp_e_cols_2_, \n               -tmp_e_cols_2_);\n               \n               \nwhich I think is clearer.",
      "revId": "1ba21606c470bfa700d2005aecc23414e05d2a68",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a1f45fa_1b5b0ccd",
        "filename": "internal/ceres/parallel_for.h",
        "patchSetId": 2
      },
      "lineNbr": 378,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-12-08T20:22:42Z",
      "side": 1,
      "message": "why does this need to be a tuple? why not just a pair of integer arguments?",
      "range": {
        "startLine": 378,
        "startChar": 48,
        "endLine": 378,
        "endChar": 53
      },
      "revId": "1ba21606c470bfa700d2005aecc23414e05d2a68",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de93b2b4_2fba5ba8",
        "filename": "internal/ceres/parallel_for.h",
        "patchSetId": 2
      },
      "lineNbr": 378,
      "author": {
        "id": 6141
      },
      "writtenOn": "2022-12-08T21:02:53Z",
      "side": 1,
      "message": "We cannot use two separate integer arguments because this is already reserved for (thread_id, loop_index) variant.",
      "parentUuid": "2a1f45fa_1b5b0ccd",
      "range": {
        "startLine": 378,
        "startChar": 48,
        "endLine": 378,
        "endChar": 53
      },
      "revId": "1ba21606c470bfa700d2005aecc23414e05d2a68",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cbe16a4_7f9dc3e0",
        "filename": "internal/ceres/parallel_for.h",
        "patchSetId": 2
      },
      "lineNbr": 390,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-12-08T20:22:42Z",
      "side": 1,
      "message": "I think for setzero you maybe able to do something even simpler/nicer no? since zero is a special value, it should just translate into a memset? it should not require any eigen at all. why not just cast to bytes and call memset on the blocks?\n\nor std::fill should do the trick too.",
      "range": {
        "startLine": 390,
        "startChar": 2,
        "endLine": 390,
        "endChar": 18
      },
      "revId": "1ba21606c470bfa700d2005aecc23414e05d2a68",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ce7996f_ca52924f",
        "filename": "internal/ceres/parallel_for.h",
        "patchSetId": 2
      },
      "lineNbr": 390,
      "author": {
        "id": 6141
      },
      "writtenOn": "2022-12-08T21:02:53Z",
      "side": 1,
      "message": "All variants end up as a size calculation followed by memset, with a couple instructions spent on:\n\n - checking for non-emptiness once (in case of std::fill)\n - checking for non-emptiness twice (in case of Eigen)\n\nhttps://godbolt.org/z/qj1f8Y3b9\n\nThis makes memset the best solution, right?",
      "parentUuid": "0cbe16a4_7f9dc3e0",
      "range": {
        "startLine": 390,
        "startChar": 2,
        "endLine": 390,
        "endChar": 18
      },
      "revId": "1ba21606c470bfa700d2005aecc23414e05d2a68",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3cefad86_9ec71c8b",
        "filename": "internal/ceres/parallel_for.h",
        "patchSetId": 2
      },
      "lineNbr": 400,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-12-08T20:22:42Z",
      "side": 1,
      "message": "should we think about refactoring these two header files, parallel_for and parallel_for_cxx into one file? the current structure is a remanent of having multiple backends in the past.",
      "revId": "1ba21606c470bfa700d2005aecc23414e05d2a68",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}