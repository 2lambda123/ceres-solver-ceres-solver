{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "46097687_a9edd1ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6141
      },
      "writtenOn": "2023-04-09T15:35:47Z",
      "side": 1,
      "message": "If TripletSparseMatrix is layout-compatible with BlockSparseMatrix (i.e. values are stored in the same order), then no sort is required at all (for both (non-)transposed CompressedRowSparseMatrix).\n\nWe essentially perform a stable sort by the leading dimension, thus, if input values corresponding to each (output) row are already stored in the expected order - we do not need to re-sort any row.\n\n\n\nHere is an example. Let us have the following block-sparse matrix:\n\n```\na b c | 0 0 | g h | 0\nd e f | 0 0 | i j | 0\n------+-----+-----+--\n0 0 0 | k l | 0 0 | o\n0 0 0 | m n | 0 0 | p\n------+-----+-----+--\n0 0 0 | 0 0 | q r | u\n0 0 0 | 0 0 | s t | v\n```\n\nThen values are stored in memory as\n\n```\nabcdefghijklmnopqrstuv\n```\n\nAnd values of, let say, 2nd row and 7th column (1-based indices here) are already stored in-order (asterisks above letter denote a values from 2nd row, asterisks below letter denote a values from 7th column)\n\n```\n   ***  **\nabcdefghijklmnopqrstuv\n       * *       * *\n```\n\nFor example, when running this code as a part of SPARSE_SCHUR linear solver, sorting is never called.",
      "revId": "42a0e0170339d2ca2375ac4b16e537e9a42c0d36",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b9b3af2a_5a67865a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2023-04-09T15:47:31Z",
      "side": 1,
      "message": "Thanks Dmitriy, I had not thought this through. In this case, why not go all the way and instead of doing the block sparse to triplet to crs matrix, why not do a method that is specific to BlockRandomAccessSparseMatrix? that is the only place where we use this method at all. \n\nIn fact an optimization like this maybe application to inner_product_computer, where there is another giant sort that is done.",
      "parentUuid": "46097687_a9edd1ce",
      "revId": "42a0e0170339d2ca2375ac4b16e537e9a42c0d36",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "72733559_17936961",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6141
      },
      "writtenOn": "2023-04-09T16:31:19Z",
      "side": 1,
      "message": "BlockRandomAccessSparseMatrix itself does not provide guarantees that conversion to CRS will be sort-less (blocks can have arbitrary order).\n\nBut we only use it in the way that has this invariant of values being stored in correct order.\n\nDo you think it makes sense to explicitly force BlockRandomSparseMatrix to have the same layout of non-zeros as BlockSparseMatrix?",
      "parentUuid": "b9b3af2a_5a67865a",
      "revId": "42a0e0170339d2ca2375ac4b16e537e9a42c0d36",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dfb9f7a0_1d00f43b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2023-04-09T18:54:30Z",
      "side": 1,
      "message": "So it turns out, that there is a tradeoff here.\nand we have tried to have it both ways.\n\nin BlockRandomAccessSparseMatrix we have two members.\n\nlayout_ which is an unordered_map which you are right will not give you in-order traversal, but there is also a vector cell_values_ which will give you what you need.\n\nhave a look at the implementation for SymmetricRightMultiplyAndAccumulate,\n\nhttps://github.com/ceres-solver/ceres-solver/blob/master/internal/ceres/block_random_access_sparse_matrix.cc#L136\n\nso I think the thing to do here would be to get rid of the underlying TripletSparseMatrix entirely, and add a method which will create a CompressedRowSparseMatrix and hand it to you in an optimal manner.\n\nI believe at one point I also tried just using a compressed row sparse matrix as the backing store instead of a compressedrowsparsematrix (it is possible to do that because of the way we use strides), but the lack of memory locality there made the writes done by the schur_eliminator more expensive, but maybe I was not thinking about this correctly and it is worth exploring this again, in which case there is no conversion needed at all?",
      "parentUuid": "72733559_17936961",
      "revId": "42a0e0170339d2ca2375ac4b16e537e9a42c0d36",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a0dec01_372ac8af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2023-04-09T19:03:20Z",
      "side": 1,
      "message": "interestingly BlockRandomAccessSparseMatrix has a context object already, so you are welcome to re-work BlockRandomAccessSparseMatrix to be more efficient as you see it fit. \n\nIt is a performance sensitive workhorse, but its possible that some of the assumptions I have made about its performance do not hold true anymore.",
      "revId": "42a0e0170339d2ca2375ac4b16e537e9a42c0d36",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ef4c3aa0_f8f76f07",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6141
      },
      "writtenOn": "2023-04-16T19:00:22Z",
      "side": 1,
      "message": "I understood that my statement \"BlockRandomAccessSparseMatrix itself does not provide guarantees that conversion to CRS will be sort-less\" is wrong, because block indices come to constructor as a lexicographically sorted pairs in std::set\n\nThus, BlockRandomAccessSparseMatrix has an invariant of values being stored in order.\n\nIt is TripletSparseMatrix that does not have that invariant.",
      "parentUuid": "dfb9f7a0_1d00f43b",
      "revId": "42a0e0170339d2ca2375ac4b16e537e9a42c0d36",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}