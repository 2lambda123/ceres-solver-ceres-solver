{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "43c453a1_bc76a7d2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-06T14:53:12Z",
      "side": 1,
      "message": "Thanks for going through this. I have some follow-up questions.",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c12d6200_3bc9f3c2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T21:32:35Z",
      "side": 1,
      "message": "thoughts on the c++14 + c++17 mix needed here?",
      "tag": "mailMessageId\u003d\u003cCABqdRUBso1Dxj41S1Rdh_GOpksOmtBPSGX76uFrYRj8yRL52pA@mail.gmail.com\u003e",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b4ffe13f_5bb1ee13",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-06T22:09:38Z",
      "side": 1,
      "message": "Mixing C++14 and C++17 is safe in my experience.\n\nWhat I\u0027m wondering about: will Ceres ship the kernels in a separate library? The `add_library` call will generate either a static or a shared library depending on `BUILD_SHARED_LIBS`.\n\nIf a separate library is not necessary, the CUDA kernels can be added to the `ceres_internal` target directly using `target_sources(... PRIVATE)` as I\u0027m assuming these are not intended to be exported. Here, the C++ standard can also be set per translation unit using `set_source_files_properties (... PROPERTIES CXX_STANDARD 14)`.\n\nYou also need to decide whether the language standard is a strict requirement and use `set_source_files_properties (... PROPERTIES CXX_STANDARD_REQUIRED ON)` accordingly as otherwise the compiler will decay to latest supported standard.",
      "parentUuid": "c12d6200_3bc9f3c2",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9543c0d8_f2d7a923",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-06T22:55:35Z",
      "side": 1,
      "message": "I\u0027m way out of my depth in cmake land here, but here\u0027s what I tried:\n\n```\nset(CUDA_STANDARD 14)\n  set_property(TARGET ceres_internal PROPERTY CUDA_STANDARD 14)\n  set_property(TARGET ceres PROPERTY CUDA_STANDARD 14)\n  target_sources(ceres_internal PRIVATE ceres_cuda_kernels.cu)\n  set_source_files_properties(ceres_cuda_kernels.cu PROPERTIES CXX_STANDARD 14)\n  set_source_files_properties(ceres_cuda_kernels.cu PROPERTIES CUDA_STANDARD 14)\n  set_source_files_properties(ceres_cuda_kernels.cu\n      PROPERTIES CXX_STANDARD_REQUIRED ON)\n```\n\nHowever, this still fails with the following cmake error:\n```\nCMake Error at internal/ceres/CMakeLists.txt:287 (add_library):\n  CUDA_STANDARD is set to invalid value \u002717\u0027\n\n\nCMake Error at internal/ceres/CMakeLists.txt:164 (add_library):\n  CUDA_STANDARD is set to invalid value \u002717\u0027\n```",
      "parentUuid": "b4ffe13f_5bb1ee13",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "01654d2e_9a5a2a16",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-06T23:05:22Z",
      "side": 1,
      "message": "I believe you need to set `CUDA_STANDARD_REQUIRED` to `ON`. Looks like `CXX_STADNARD*` properties do not apply to CUDA source files.",
      "parentUuid": "9543c0d8_f2d7a923",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ece38331_913ac00f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-06T23:27:26Z",
      "side": 1,
      "message": "Done, still no dice - same error.",
      "parentUuid": "01654d2e_9a5a2a16",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "817fb90c_062796e6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-07T00:07:45Z",
      "side": 1,
      "message": "Hmm, looks like this was fixed in cmake 3.17: \nhttps://gitlab.kitware.com/cmake/cmake/-/issues/19123\n\nUnfortunately 20.04 is still using cmake 3.16.3",
      "parentUuid": "ece38331_913ac00f",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d6ba4fb1_7c905063",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-07T00:12:10Z",
      "side": 1,
      "message": "Thanks. I already suspected a CMake issue because I tried reproducing the problem locally using CUDA 11.7, `nvcc --version`\n```\nnvcc: NVIDIA (R) Cuda compiler driver\nCopyright (c) 2005-2022 NVIDIA Corporation\nBuilt on Tue_May__3_18:49:52_PDT_2022\nCuda compilation tools, release 11.7, V11.7.64\nBuild cuda_11.7.r11.7/compiler.31294372_0\n```\nand CMake 3.23.2 but couldn\u0027t.\n\nAfter checking the `nvcc` flags it looks like setting these for individual CUDA sources files is not possible after all.\n\nCould you try setting\n```\nset (CMAKE_CUDA_STANDARD 14)\nset (CMAKE_CUDA_STANDARD_REQUIRED ON)\n```\nsomewhere in the main `CMakeLists.txt` instead? This seems to work for me.\n\nSince the kernels are compiled into the library, propagating the CUDA compiler dialect is unnecessary and using the above variables to initialize the compiler flags should be sufficient.",
      "parentUuid": "ece38331_913ac00f",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5b793a18_d749c41c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-07T00:41:24Z",
      "side": 1,
      "message": "This still does not work. I put this at the top of the main CMakeLists.txt:\n```\nset(CMAKE_CUDA_STANDARD 14)\nset(CMAKE_CUDA_STANDARD_REQUIRED TRUE)\n```\n\nHowever, it throws the following error:\n\n```\nCMake Error in internal/ceres/CMakeLists.txt:\n  Target \"ceres\" requires the language dialect \"CUDA17\" (with compiler\n  extensions), but CMake does not know the compile flags to use to enable it.\n\n\nCMake Error in internal/ceres/CMakeLists.txt:\n  Target \"ceres_internal\" requires the language dialect \"CUDA17\" (with\n  compiler extensions), but CMake does not know the compile flags to use to\n  enable it.\n```\n\nIt seems my cmake (3.16.3) is incorrectly intertwining the CXX and CUDA standards. Just to verify, I modified the following line:\n```\ntarget_compile_features(ceres PUBLIC cxx_std_17)\n```\nI tried commenting it out, and changing it to 14. Both succeeded with cmake, but of course Ceres won\u0027t compile without 17 support.\n\nI think our only solution is to compile the kernels into a separate library and link it into ceres. We don\u0027t need to publicly export the symbols from the cuda kernels library, and we can even do that using static libs. Is it possible to:\n1. Compile ceres_cuda_kernels into a static lib\n2. Link ceres_cuda_kernels to ceres.a as well as ceres.so?",
      "parentUuid": "d6ba4fb1_7c905063",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "85074d55_efbeed3c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-07T09:36:43Z",
      "side": 1,
      "message": "Yes, you can compile the kernels into a static library but you must pass the `STATIC` modifier to the `add_library` call. An object library (similar to `ceres_internal`) would also suffice if the kernels are not intended to be shipped/installed separately.\n\nI would also document your findings in a comment in the affected `CMakeLists.txt` so we can drop the workaround once a newer version of CMake can be used by Ceres.",
      "parentUuid": "5b793a18_d749c41c",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bc9e6160_c8d16135",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-07T13:46:48Z",
      "side": 1,
      "message": "It turns out that adding `STATIC` and `OBJECT` modifiers to the kernel object invokes the same Cmake bug: it inherits CUDA 17, no matter what else is done.\nUnfortunately it looks like the only way to do this is to have `ceres_cuda_kernels` link as a separate library and link it to ceres, as I did in this original commit.",
      "parentUuid": "85074d55_efbeed3c",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e136eba9_febf97eb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-07T13:57:38Z",
      "side": 1,
      "message": "Your original implementation generates either a `STATIC` or a `SHARED` library depending on `BUILD_SHARED_LIBS` value. If I understand you correctly, you must always build a `SHARED` library to avoid the bug, correct? This is of course a huge downside because you need to export the symbols correctly, among other things.",
      "parentUuid": "bc9e6160_c8d16135",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d0a64884_f41f6241",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-07T14:09:27Z",
      "side": 1,
      "message": "The original implementation produced a separate `libceres_cuda_kernels.a`, irrespective of `BUILD_SHARED_LIBS`. `libceres.a` or `libceres.so` just links to `libceres_cuda_kernels.a`.\n\nActually, there may be a nuclear option: Just scrap the cmake wrappers to compile the kernels, and manually invoke nvcc to compile them. Then we should be able to link the produced objects into ceres. I\u0027m not sure this would work, but if you think this is preferable to exporting a separate library just for the cuda kernels, it\u0027s worth trying out. Thoughts?",
      "parentUuid": "e136eba9_febf97eb",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0f5e1623_7522bdad",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-07T14:22:36Z",
      "side": 1,
      "message": "This article describes how to separately compile and link cuda units with nvcc and g++: \n\nhttps://developer.nvidia.com/blog/separate-compilation-linking-cuda-device-code/\n\nI\u0027m pretty sure this would work on linux, but it might break the build with cuda on other platforms.",
      "parentUuid": "d0a64884_f41f6241",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2f3a6c73_2a819751",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 6612
      },
      "writtenOn": "2022-06-07T14:27:27Z",
      "side": 1,
      "message": "If you don\u0027t pass any library type to `add_library`, its type will depend on `BUILD_SHARED_LIBS`. See https://cmake.org/cmake/help/latest/command/add_library.html:\n\n\u003e  If no type is given explicitly the type is STATIC or SHARED based on whether the current value of the variable BUILD_SHARED_LIBS is ON",
      "parentUuid": "0f5e1623_7522bdad",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f132222b_d7a4f19d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-07T14:45:11Z",
      "side": 1,
      "message": "Ah, you are right.\n\nRunning this:\n```\nrm -rf * \u0026\u0026 cmake .. -DCMAKE_BUILD_TYPE\u003dRelease -DBUILD_SHARED_LIBS\u003dON \u0026\u0026 make -j32 bundle_adjuster \u0026\u0026 ll lib\n```\nProduces:\n```\ndrwxrwxr-x 2 joydeepb joydeepb 4.0K Jun  7 09:38 .\ndrwxrwxr-x 9 joydeepb joydeepb 4.0K Jun  7 09:37 ..\n-rwxrwxr-x 1 joydeepb joydeepb 807K Jun  7 09:37 libceres_cuda_kernels.so\nlrwxrwxrwx 1 joydeepb joydeepb   13 Jun  7 09:38 libceres.so -\u003e libceres.so.3\n-rwxrwxr-x 1 joydeepb joydeepb 4.4M Jun  7 09:38 libceres.so.2.2.0\nlrwxrwxrwx 1 joydeepb joydeepb   17 Jun  7 09:38 libceres.so.3 -\u003e libceres.so.2.2.0\n```\n\nWhile running this:\n```\nrm -rf * \u0026\u0026 cmake .. -DCMAKE_BUILD_TYPE\u003dRelease \u0026\u0026 make -j32 bundle_adjuster \u0026\u0026 ll lib\n```\nProduces:\n```\ndrwxrwxr-x 2 joydeepb joydeepb 4.0K Jun  7 09:37 .\ndrwxrwxr-x 9 joydeepb joydeepb 4.0K Jun  7 09:36 ..\n-rw-rw-r-- 1 joydeepb joydeepb  11M Jun  7 09:37 libceres.a\n-rw-rw-r-- 1 joydeepb joydeepb  22K Jun  7 09:36 libceres_cuda_kernels.a\n```\n\nComing back to how to compile and link the cuda kernels: Until we can move to cmake 3.17, due to the cmake bug that mixes up C++ and Cuda standards, we will be unable to compile cuda kernels into the same unit as ceres. I\u0027ve tried compiling the kernels to `OBJECT`, `STATIC`, and linking them in with explicit cuda 14 flags, to no avail - it still throws the cuda17 error. The only thing that has worked is the above: compile the kernels into a separate unit, and link them to ceres.",
      "parentUuid": "2f3a6c73_2a819751",
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edaa91f0_51013f0f",
        "filename": "internal/ceres/CMakeLists.txt",
        "patchSetId": 2
      },
      "lineNbr": 152,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T00:31:21Z",
      "side": 1,
      "message": "I have no idea what havoc this will wreck.",
      "range": {
        "startLine": 152,
        "startChar": 45,
        "endLine": 152,
        "endChar": 51
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20c1a969_c8abdc67",
        "filename": "internal/ceres/CMakeLists.txt",
        "patchSetId": 2
      },
      "lineNbr": 152,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-06T14:53:12Z",
      "side": 1,
      "message": "Agreed, me neither. We need a \"good\" way to compile cuda kernels alongside ceres for the kinds of extensions we\u0027re planning in the future. Now is probably a good time to figure out what the correct way to do it is.",
      "parentUuid": "edaa91f0_51013f0f",
      "range": {
        "startLine": 152,
        "startChar": 45,
        "endLine": 152,
        "endChar": 51
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "172a3c6c_7514e6f0",
        "filename": "internal/ceres/CMakeLists.txt",
        "patchSetId": 2
      },
      "lineNbr": 152,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T15:23:55Z",
      "side": 1,
      "message": "Alex, do you know what is the right thing here?",
      "parentUuid": "20c1a969_c8abdc67",
      "range": {
        "startLine": 152,
        "startChar": 45,
        "endLine": 152,
        "endChar": 51
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30ea4a01_666b84a0",
        "filename": "internal/ceres/ceres_cuda_kernels.h",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T00:31:21Z",
      "side": 1,
      "message": "shouldn\u0027t there be cuda functions for this already?",
      "range": {
        "startLine": 50,
        "startChar": 5,
        "endLine": 50,
        "endChar": 20
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b742bf37_3ac690fe",
        "filename": "internal/ceres/ceres_cuda_kernels.h",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-06T14:53:12Z",
      "side": 1,
      "message": "There is `cudaMemset`, but out of a (potential over-) abundance of caution this calls a kernel that does a safe type cast. I could be swayed to revert to cudaMemset if you think that is preferable.",
      "parentUuid": "30ea4a01_666b84a0",
      "range": {
        "startLine": 50,
        "startChar": 5,
        "endLine": 50,
        "endChar": 20
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "226fccd3_7d698ce9",
        "filename": "internal/ceres/ceres_cuda_kernels.h",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T15:23:55Z",
      "side": 1,
      "message": "you should be able to make a type specific cudaMemset call no?",
      "parentUuid": "b742bf37_3ac690fe",
      "range": {
        "startLine": 50,
        "startChar": 5,
        "endLine": 50,
        "endChar": 20
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72e105c5_a70d6499",
        "filename": "internal/ceres/ceres_cuda_kernels.h",
        "patchSetId": 2
      },
      "lineNbr": 56,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T00:31:21Z",
      "side": 1,
      "message": "This needs a better name, not sure what though.\n\nalso are you sure you x \u003d x + y and not x \u003d x + a * y or something like that in which case you just have axpy no?",
      "range": {
        "startLine": 56,
        "startChar": 5,
        "endLine": 56,
        "endChar": 21
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6f63b0c_f13d2d4c",
        "filename": "internal/ceres/ceres_cuda_kernels.h",
        "patchSetId": 2
      },
      "lineNbr": 56,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-06T14:53:12Z",
      "side": 1,
      "message": "It does need a better more descriptive name. \nIt actually does more than just x \u003d x + y. It operates on different types for x and y, and casts to the destination type before performing the addition.\ncublas *axpy operations operate on the same type for all values.",
      "parentUuid": "72e105c5_a70d6499",
      "range": {
        "startLine": 56,
        "startChar": 5,
        "endLine": 56,
        "endChar": 21
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fbdd307b_30b4d03f",
        "filename": "internal/ceres/ceres_cuda_kernels.h",
        "patchSetId": 2
      },
      "lineNbr": 56,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T15:23:55Z",
      "side": 1,
      "message": "dsaxpy is a good name, there is a precendent for this typed of mixed naming in blas.",
      "parentUuid": "e6f63b0c_f13d2d4c",
      "range": {
        "startLine": 56,
        "startChar": 5,
        "endLine": 56,
        "endChar": 21
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cea1c21d_2603ad94",
        "filename": "internal/ceres/dense_cholesky.cc",
        "patchSetId": 2
      },
      "lineNbr": 363,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T15:23:55Z",
      "side": 1,
      "message": "I think it will make the code much simpler to read if you introduced private high level methods which took care of doing the operation while using the various member variables. For example\n\ncusolver_handle,\n                       CUBLAS_FILL_MODE_LOWER,\n                       num_cols,\n                       1,\n                       lhs.data(),\n                       num_cols,\n                       solution.data(),\n                       num_cols,\n                       error.data()\n                       \n                       \nshould be replaced by a private member which takes care of the cuda boiler plate etc.",
      "range": {
        "startLine": 363,
        "startChar": 28,
        "endLine": 363,
        "endChar": 59
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e689bfd7_2e89f16d",
        "filename": "internal/ceres/dense_cholesky.cc",
        "patchSetId": 2
      },
      "lineNbr": 431,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T00:31:21Z",
      "side": 1,
      "message": "is there a point to splitting this out into its own function, its called exactly once.",
      "range": {
        "startLine": 431,
        "startChar": 28,
        "endLine": 431,
        "endChar": 38
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c5d387c_2d986ece",
        "filename": "internal/ceres/dense_cholesky.cc",
        "patchSetId": 2
      },
      "lineNbr": 431,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-06T14:53:12Z",
      "side": 1,
      "message": "I\u0027ll move it to a private method. Factorizing it out improves readability of the iterative solver.",
      "parentUuid": "e689bfd7_2e89f16d",
      "range": {
        "startLine": 431,
        "startChar": 28,
        "endLine": 431,
        "endChar": 38
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d24dc6c_8f1185d4",
        "filename": "internal/ceres/dense_cholesky.h",
        "patchSetId": 2
      },
      "lineNbr": 180,
      "author": {
        "id": 5002
      },
      "writtenOn": "2022-06-06T00:31:21Z",
      "side": 1,
      "message": "unless you plan to test this method on its own -- I recommend having this just as a private method of cudadensecholeskymixedprecision.",
      "range": {
        "startLine": 180,
        "startChar": 28,
        "endLine": 180,
        "endChar": 38
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f0cb72f_a25fb824",
        "filename": "internal/ceres/dense_cholesky.h",
        "patchSetId": 2
      },
      "lineNbr": 180,
      "author": {
        "id": 5135
      },
      "writtenOn": "2022-06-06T14:53:12Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "0d24dc6c_8f1185d4",
      "range": {
        "startLine": 180,
        "startChar": 28,
        "endLine": 180,
        "endChar": 38
      },
      "revId": "b812d20e5b0a770f86211feeeb4e37865d6de72e",
      "serverId": "cdcfcfbe-2044-3b1f-b5d4-da77ad542329"
    }
  ]
}